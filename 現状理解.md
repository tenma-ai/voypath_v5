# ç¾çŠ¶ç†è§£ãƒ»ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆè©³ç´°æ›¸

## ğŸš¨ **ç·Šæ€¥å¯¾å¿œãŒå¿…è¦ãªè¨­è¨ˆä¿®æ­£äº‹é …**

### **1. Google Maps APIçµ±åˆ**
- **ä¿®æ­£**: Google Places APIã§ã¯ãªãã€**Google Maps APIå˜ä¸€ã‚­ãƒ¼**ã§ã™ã¹ã¦ã®æ©Ÿèƒ½ã‚’æä¾›
- **å¯¾å¿œ**: APIçµ±åˆéƒ¨åˆ†ã‚’Google Maps JavaScript API + Places Library ã§å®Ÿè£…

### **2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã®èª²é¡Œç¢ºèª**

#### **ç¾åœ¨ã®placesãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ åˆ†æ**
```sql
-- ç¾åœ¨ã®è¨­è¨ˆ: å€‹äººå¸Œæœ›åœ°ã¨ã‚°ãƒ«ãƒ¼ãƒ—æ¡ç”¨åœ°ãŒåŒä¸€ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE places (
  id UUID PRIMARY KEY,
  trip_id UUID NOT NULL,        -- âœ… æ—…è¡Œã«ç´ã¥ã
  user_id UUID NOT NULL,        -- âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç´ã¥ã
  scheduled BOOLEAN DEFAULT false, -- æ¡ç”¨/æœªæ¡ç”¨çŠ¶æ…‹
  -- ãã®ä»–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰...
);
```

#### **å•é¡Œç‚¹ã¨è§£æ±ºç­–**
- **ç¾çŠ¶**: å€‹äººå¸Œæœ›åœ°ã¨æ¡ç”¨åœ°ãŒæ··åœ¨
- **è§£æ±º**: `scheduled`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§åˆ†é›¢
  - `scheduled = false`: å€‹äººå¸Œæœ›åœ°
  - `scheduled = true`: ã‚°ãƒ«ãƒ¼ãƒ—æ¡ç”¨åœ°

---

## ğŸ¯ **çµ±ä¸€Google Maps APIå ´æ‰€å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ**

### **6ã¤ã®å…¥åŠ›å ´æ‰€ã«ãŠã‘ã‚‹çµ±ä¸€ãƒ•ãƒ­ãƒ¼**

#### **å¯¾è±¡å ´æ‰€**
1. **Create Trip: Departure Location** (æ—…è¡Œä½œæˆæ™‚ã®å‡ºç™ºåœ°)
2. **Create Trip: Destination** (æ—…è¡Œä½œæˆæ™‚ã®ç›®çš„åœ°) 
3. **Map View: Add Place** (ãƒãƒƒãƒ—ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ã®å ´æ‰€è¿½åŠ )
4. **List View (Timeline): Add Place** (ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ã®å ´æ‰€è¿½åŠ )
5. **Calendar View: Add Place** (ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ã®å ´æ‰€è¿½åŠ )
6. **My Places: Add Place** (ãƒã‚¤ãƒ—ãƒ¬ã‚¤ã‚¹ã‹ã‚‰ã®å ´æ‰€è¿½åŠ )

### **çµ±ä¸€ãƒ•ãƒ­ãƒ¼è¨­è¨ˆæ¦‚è¦**

#### **Phase 1: æ–‡å­—å…¥åŠ› â†’ ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³å€™è£œè¡¨ç¤º**
```typescript
interface PlaceSearchInput {
  inputValue: string;
  location?: {lat: number, lng: number}; // ç¾åœ¨ä½ç½®ãƒ»æ—…è¡Œåœ°åŸŸã‚’åŸºæº–ã¨ã—ãŸæ¤œç´¢
  searchRadius?: number; // æ¤œç´¢åŠå¾„ (km)
  placeTypes?: string[]; // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¯¾è±¡ã®Place Type
  language: 'en'; // è‹±èªå›ºå®š
}

// Google Maps API Places Library Integration
const searchPlaces = async (input: PlaceSearchInput): Promise<GooglePlace[]> => {
  const google = await loadGoogleMapsAPI();
  const service = new google.maps.places.PlacesService(document.createElement('div'));
  
  return new Promise((resolve) => {
    service.textSearch({
      query: input.inputValue,
      location: input.location ? new google.maps.LatLng(input.location.lat, input.location.lng) : undefined,
      radius: input.searchRadius ? input.searchRadius * 1000 : 50000, // Convert to meters
      type: input.placeTypes?.[0] as any,
      language: 'en'
    }, (results, status) => {
      if (status === google.maps.places.PlacesServiceStatus.OK && results) {
        resolve(results.map(convertToGooglePlace));
      } else {
        resolve([]);
      }
    });
  });
};
```

#### **Phase 2: å€™è£œé¸æŠ â†’ è©³ç´°è¨­å®šãƒšãƒ¼ã‚¸é·ç§»**
```typescript
interface SelectedPlaceData {
  // Google Maps APIã‹ã‚‰å–å¾—ã•ã‚Œã‚‹ã‚³ã‚¢æƒ…å ±
  google_place_id: string;
  name: string;
  formatted_address: string;
  geometry: {
    location: { lat: number; lng: number; }
  };
  rating?: number;
  user_ratings_total?: number;
  price_level?: number;
  types: string[];
  photos?: GooglePlacePhoto[];
  opening_hours?: {
    open_now?: boolean;
    weekday_text?: string[];
  };
  
  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±
  source_location: 'create_trip_departure' | 'create_trip_destination' | 'map_view' | 'list_view' | 'calendar_view' | 'my_places';
  selected_date?: string; // calendar/list viewã®å ´åˆ
  selected_time_slot?: string; // list viewã®å ´åˆ
}

// é¸æŠæ™‚ã®é·ç§»ãƒ­ã‚¸ãƒƒã‚¯
const handlePlaceSelection = (place: GooglePlace, context: PlaceInputContext) => {
  const placeData: SelectedPlaceData = {
    google_place_id: place.place_id,
    name: place.name,
    formatted_address: place.formatted_address,
    geometry: place.geometry,
    rating: place.rating,
    user_ratings_total: place.user_ratings_total,
    price_level: place.price_level,
    types: place.types,
    photos: place.photos,
    opening_hours: place.opening_hours,
    source_location: context.source,
    selected_date: context.date,
    selected_time_slot: context.timeSlot
  };
  
  // context.sourceã«å¿œã˜ã¦é©åˆ‡ãªé·ç§»å…ˆã‚’æ±ºå®š
  if (context.source === 'create_trip_departure' || context.source === 'create_trip_destination') {
    // Create Trip Modalå†…ã§ç›´æ¥åæ˜ 
    updateTripFormData(context.source, placeData);
  } else {
    // Add Placeè©³ç´°è¨­å®šãƒšãƒ¼ã‚¸ã«é·ç§»
    navigateToAddPlaceDetail(placeData);
  }
};
```

#### **Phase 3: è©³ç´°è¨­å®š â†’ å®Ÿéš›ã®è¿½åŠ å‡¦ç†**
```typescript
interface PlaceDetailForm {
  // åŸºæœ¬æƒ…å ± (Phase 2ã‹ã‚‰ç¶™æ‰¿)
  selectedPlace: SelectedPlaceData;
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šé …ç›®
  wish_level: 1 | 2 | 3 | 4 | 5; // å¸Œæœ›åº¦
  stay_duration_minutes: number; // æ»åœ¨æ™‚é–“
  visit_date?: string; // è¨ªå•å¸Œæœ›æ—¥
  preferred_time_slots?: string[]; // å¸Œæœ›æ™‚é–“å¸¯
  notes?: string; // ãƒ¡ãƒ¢
  estimated_cost?: number; // äºˆç®—
  transport_mode?: 'walking' | 'public_transport' | 'car' | 'bicycle' | 'taxi';
  
  // è‡ªå‹•è¨ˆç®—é …ç›®
  category: string; // Google Maps typesã‹ã‚‰è‡ªå‹•åˆ¤å®š
  image_url?: string; // Google Places photosã‹ã‚‰å–å¾—
}

// æœ€çµ‚çš„ãªPlaces DBã¸ã®ä¿å­˜
const savePlaceToDatabase = async (formData: PlaceDetailForm, currentTrip: Trip, currentUser: User) => {
  const placeRecord = {
    // Google Maps API data
    name: formData.selectedPlace.name,
    address: formData.selectedPlace.formatted_address,
    latitude: formData.selectedPlace.geometry.location.lat,
    longitude: formData.selectedPlace.geometry.location.lng,
    external_id: formData.selectedPlace.google_place_id,
    rating: formData.selectedPlace.rating,
    
    // User preferences
    wish_level: formData.wish_level,
    stay_duration_minutes: formData.stay_duration_minutes,
    visit_date: formData.visit_date,
    preferred_time_slots: formData.preferred_time_slots,
    notes: formData.notes,
    estimated_cost: formData.estimated_cost,
    transport_mode: formData.transport_mode,
    
    // Auto-generated
    category: determineCategoryFromTypes(formData.selectedPlace.types),
    image_url: formData.selectedPlace.photos?.[0] ? 
      getGooglePlacePhotoUrl(formData.selectedPlace.photos[0]) : null,
    
    // Relationships
    trip_id: currentTrip.id,
    user_id: currentUser.id,
    scheduled: false, // å€‹äººå¸Œæœ›åœ°ã¨ã—ã¦ä¿å­˜
    source: 'user'
  };
  
  await supabase.from('places').insert(placeRecord);
};
```

---

### **å„å…¥åŠ›å ´æ‰€ã®å…·ä½“çš„å®Ÿè£…æ–¹é‡**

#### **1. Create Trip: Departure Location**
```typescript
// CreateTripModal.tsx ã® departure_location input
const DepartureLocationInput: React.FC = () => {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState<GooglePlace[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  
  const handleInputChange = async (value: string) => {
    setQuery(value);
    if (value.length >= 2) {
      const places = await searchPlaces({
        inputValue: value,
        language: 'en',
        placeTypes: ['establishment', 'transit_station'] // ä¸»è¦é§…ãƒ»ç©ºæ¸¯ã‚’å„ªå…ˆ
      });
      setSuggestions(places);
      setShowSuggestions(true);
    } else {
      setShowSuggestions(false);
    }
  };
  
  const handleSuggestionSelect = (place: GooglePlace) => {
    setQuery(place.name);
    setFormData(prev => ({
      ...prev,
      departureLocation: place.name,
      departure_coordinates: {
        lat: place.geometry.location.lat,
        lng: place.geometry.location.lng
      }
    }));
    setShowSuggestions(false);
  };
  
  return (
    <div className="relative">
      <input
        type="text"
        value={query}
        onChange={(e) => handleInputChange(e.target.value)}
        placeholder="Search departure location..."
        className="w-full px-4 py-3 border-2 border-slate-200/50 dark:border-slate-600/50 rounded-2xl"
      />
      
      {showSuggestions && suggestions.length > 0 && (
        <div className="absolute top-full mt-2 w-full bg-white dark:bg-slate-800 rounded-2xl border border-slate-200/50 dark:border-slate-700/50 shadow-glass z-50">
          {suggestions.map((place) => (
            <button
              key={place.place_id}
              onClick={() => handleSuggestionSelect(place)}
              className="w-full p-4 text-left hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors border-b border-slate-200/30 dark:border-slate-700/30 last:border-b-0"
            >
              <div className="flex items-center space-x-3">
                <MapPin className="w-5 h-5 text-primary-500" />
                <div className="flex-1">
                  <h4 className="font-semibold text-slate-900 dark:text-slate-100">
                    {place.name}
                  </h4>
                  <p className="text-sm text-slate-500 dark:text-slate-400">
                    {place.formatted_address}
                  </p>
                </div>
              </div>
            </button>
          ))}
        </div>
      )}
    </div>
  );
};
```

#### **2. Create Trip: Destination**
```typescript
// CreateTripModal.tsx ã® destination input
const DestinationInput: React.FC = () => {
  // Departure Locationã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã ãŒã€æ¤œç´¢ç¯„å›²ã‚’åºƒã‚ã«è¨­å®š
  const handleInputChange = async (value: string) => {
    setQuery(value);
    if (value.length >= 2) {
      const places = await searchPlaces({
        inputValue: value,
        language: 'en',
        searchRadius: 100, // ã‚ˆã‚Šåºƒã„ç¯„å›²ã§æ¤œç´¢
        placeTypes: ['locality', 'administrative_area', 'country'] // éƒ½å¸‚ãƒ»åœ°åŸŸãƒ¬ãƒ™ãƒ«
      });
      setSuggestions(places);
      setShowSuggestions(true);
    }
  };
  
  // æ®‹ã‚Šã¯ Departure Location ã¨åŒã˜æ§‹é€ 
};
```

#### **3. Map View: Add Place**
```typescript
// MapView.tsx ã® search input
const MapViewSearchInput: React.FC = () => {
  const { currentTrip } = useStore();
  
  const handleInputChange = async (value: string) => {
    setQuery(value);
    if (value.length >= 2) {
      // ç¾åœ¨ã®æ—…è¡Œã®åœ°ç†çš„ç¯„å›²å†…ã§æ¤œç´¢
      const tripCenter = calculateTripCenter(currentTrip);
      const places = await searchPlaces({
        inputValue: value,
        location: tripCenter,
        searchRadius: 50, // æ—…è¡Œç¯„å›²å†…
        language: 'en'
      });
      setSuggestions(places);
      setShowSuggestions(true);
    }
  };
  
  const handleSuggestionSelect = (place: GooglePlace) => {
    const placeData: SelectedPlaceData = {
      ...convertGooglePlace(place),
      source_location: 'map_view'
    };
    navigateToAddPlaceDetail(placeData);
  };
  
  // UI structure similar to Create Trip inputs
};
```

#### **4. List View (Timeline): Add Place**
```typescript
// ListView.tsx ã® AddPlaceModal
const ListViewAddPlaceModal: React.FC<{timeSlot: string, date: string}> = ({ timeSlot, date }) => {
  const handleSuggestionSelect = (place: GooglePlace) => {
    const placeData: SelectedPlaceData = {
      ...convertGooglePlace(place),
      source_location: 'list_view',
      selected_date: date,
      selected_time_slot: timeSlot
    };
    onClose();
    navigateToAddPlaceDetail(placeData);
  };
  
  // Same search logic as Map View but with timeline context
};
```

#### **5. Calendar View: Add Place**
```typescript
// CalendarView.tsx ã® AddPlaceModal
const CalendarViewAddPlaceModal: React.FC<{date: string}> = ({ date }) => {
  const handleSuggestionSelect = (place: GooglePlace) => {
    const placeData: SelectedPlaceData = {
      ...convertGooglePlace(place),
      source_location: 'calendar_view',
      selected_date: date
    };
    onClose();
    navigateToAddPlaceDetail(placeData);
  };
  
  // Same search logic as Map View but with calendar context
};
```

#### **6. My Places: Add Place**
```typescript
// AddPlacePage.tsx ã® main search
const MyPlacesSearchInput: React.FC = () => {
  const handleSuggestionSelect = (place: GooglePlace) => {
    const placeData: SelectedPlaceData = {
      ...convertGooglePlace(place),
      source_location: 'my_places'
    };
    setSelectedPlace(placeData);
    // åŒã˜ãƒšãƒ¼ã‚¸å†…ã§è©³ç´°ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¡¨ç¤º
  };
  
  // Same search logic as other views
};
```

---

### **çµ±ä¸€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ**

#### **å…±é€šPlaceSearchInputã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
```typescript
interface PlaceSearchInputProps {
  value: string;
  onChange: (value: string) => void;
  onPlaceSelect: (place: GooglePlace) => void;
  placeholder?: string;
  searchContext?: {
    location?: {lat: number, lng: number};
    radius?: number;
    types?: string[];
  };
  className?: string;
}

export const PlaceSearchInput: React.FC<PlaceSearchInputProps> = ({
  value,
  onChange,
  onPlaceSelect,
  placeholder = "Search for places...",
  searchContext,
  className
}) => {
  const [suggestions, setSuggestions] = useState<GooglePlace[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  const handleInputChange = async (newValue: string) => {
    onChange(newValue);
    
    if (newValue.length >= 2) {
      setIsLoading(true);
      try {
        const places = await searchPlaces({
          inputValue: newValue,
          location: searchContext?.location,
          searchRadius: searchContext?.radius || 50,
          placeTypes: searchContext?.types,
          language: 'en'
        });
        setSuggestions(places);
        setShowSuggestions(true);
      } catch (error) {
        console.error('Place search error:', error);
        setSuggestions([]);
      } finally {
        setIsLoading(false);
      }
    } else {
      setShowSuggestions(false);
    }
  };
  
  const handleSuggestionClick = (place: GooglePlace) => {
    onChange(place.name);
    setShowSuggestions(false);
    onPlaceSelect(place);
  };
  
  return (
    <div className={`relative ${className}`}>
      <div className="relative">
        <input
          type="text"
          value={value}
          onChange={(e) => handleInputChange(e.target.value)}
          placeholder={placeholder}
          className="w-full pl-12 pr-4 py-3 border-2 border-slate-200/50 dark:border-slate-600/50 rounded-2xl bg-white/80 dark:bg-slate-800/80 backdrop-blur-xl text-slate-900 dark:text-slate-100 placeholder-slate-500 focus:ring-2 focus:ring-primary-500/50 focus:border-primary-500/50 transition-all duration-300"
        />
        <Search className="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" />
        {isLoading && (
          <div className="absolute right-4 top-1/2 transform -translate-y-1/2">
            <div className="w-4 h-4 border-2 border-slate-300 border-t-primary-500 rounded-full animate-spin" />
          </div>
        )}
      </div>
      
      <AnimatePresence>
        {showSuggestions && suggestions.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute top-full mt-2 w-full bg-white/95 dark:bg-slate-800/95 backdrop-blur-xl rounded-2xl shadow-glass border border-slate-200/50 dark:border-slate-700/50 overflow-hidden z-50"
          >
            {suggestions.map((place) => (
              <motion.button
                key={place.place_id}
                onClick={() => handleSuggestionClick(place)}
                className="w-full p-4 text-left hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors border-b border-slate-200/30 dark:border-slate-700/30 last:border-b-0"
                whileHover={{ x: 4 }}
              >
                <div className="flex items-center space-x-3">
                  <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-xl flex items-center justify-center">
                    <MapPin className="w-5 h-5 text-white" />
                  </div>
                  <div className="flex-1">
                    <h4 className="font-semibold text-slate-900 dark:text-slate-100">
                      {place.name}
                    </h4>
                    <p className="text-sm text-slate-500 dark:text-slate-400">
                      {place.formatted_address}
                    </p>
                    {place.rating && (
                      <div className="flex items-center space-x-1 mt-1">
                        <Star className="w-3 h-3 text-yellow-400 fill-current" />
                        <span className="text-xs text-slate-600 dark:text-slate-400">
                          {place.rating} ({place.user_ratings_total} reviews)
                        </span>
                      </div>
                    )}
                  </div>
                  <Plus className="w-5 h-5 text-primary-500" />
                </div>
              </motion.button>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};
```

---

### **Google Maps API Serviceçµ±åˆ**

#### **çµ±ä¸€SearchService**
```typescript
// services/PlaceSearchService.ts
export class PlaceSearchService {
  private static googleMapsAPI: typeof google | null = null;
  
  static async initialize() {
    if (!this.googleMapsAPI) {
      this.googleMapsAPI = await loadGoogleMapsAPI();
    }
  }
  
  static async searchPlaces(request: PlaceSearchRequest): Promise<GooglePlace[]> {
    await this.initialize();
    
    if (!this.googleMapsAPI) {
      throw new Error('Google Maps API not loaded');
    }
    
    const service = new this.googleMapsAPI.maps.places.PlacesService(
      document.createElement('div')
    );
    
    return new Promise((resolve, reject) => {
      const searchRequest: google.maps.places.TextSearchRequest = {
        query: request.inputValue,
        location: request.location ? 
          new this.googleMapsAPI!.maps.LatLng(request.location.lat, request.location.lng) : 
          undefined,
        radius: request.searchRadius ? request.searchRadius * 1000 : undefined,
        type: request.placeTypes?.[0] as any,
        language: 'en'
      };
      
      service.textSearch(searchRequest, (results, status) => {
        if (status === this.googleMapsAPI!.maps.places.PlacesServiceStatus.OK && results) {
          const places = results.map(this.convertToGooglePlace);
          resolve(places);
        } else if (status === this.googleMapsAPI!.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
          resolve([]);
        } else {
          reject(new Error(`Places search failed: ${status}`));
        }
      });
    });
  }
  
  private static convertToGooglePlace(place: google.maps.places.PlaceResult): GooglePlace {
    return {
      place_id: place.place_id || '',
      name: place.name || '',
      formatted_address: place.formatted_address || '',
      geometry: {
        location: {
          lat: place.geometry?.location?.lat() || 0,
          lng: place.geometry?.location?.lng() || 0,
        },
      },
      rating: place.rating,
      user_ratings_total: place.user_ratings_total,
      price_level: place.price_level,
      types: place.types || [],
      photos: place.photos?.map(photo => ({
        photo_reference: photo.photo_reference,
        height: photo.height,
        width: photo.width,
      })),
      opening_hours: place.opening_hours ? {
        open_now: place.opening_hours.open_now,
        weekday_text: place.opening_hours.weekday_text,
      } : undefined,
      vicinity: place.vicinity,
    };
  }
  
  static getPhotoUrl(photoReference: string, maxWidth: number = 400): string {
    return `https://maps.googleapis.com/maps/api/place/photo?maxwidth=${maxWidth}&photoreference=${photoReference}&key=${process.env.REACT_APP_GOOGLE_MAPS_API_KEY}`;
  }
}
```

---

### **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° & ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**

#### **APIå¤±æ•—æ™‚ã®å¯¾å‡¦**
```typescript
export const searchPlacesWithFallback = async (request: PlaceSearchRequest): Promise<GooglePlace[]> => {
  try {
    // Primary: Google Maps API
    return await PlaceSearchService.searchPlaces(request);
  } catch (error) {
    console.warn('Google Maps API failed, using fallback:', error);
    
    try {
      // Secondary: Supabase Edge Function proxy
      return await searchPlacesViaProxy(request);
    } catch (proxyError) {
      console.warn('Proxy API failed, using mock data:', proxyError);
      
      // Tertiary: Mock data for development
      return generateMockSearchResults(request.inputValue);
    }
  }
};

const generateMockSearchResults = (query: string): GooglePlace[] => {
  const mockResults = [
    {
      place_id: 'mock_1',
      name: `${query} - Popular Attraction`,
      formatted_address: `123 ${query} Street, City, Country`,
      geometry: { location: { lat: 35.6762, lng: 139.6503 } },
      rating: 4.2,
      user_ratings_total: 1250,
      types: ['tourist_attraction'],
    },
    {
      place_id: 'mock_2', 
      name: `${query} Station`,
      formatted_address: `${query} Transportation Hub`,
      geometry: { location: { lat: 35.6762, lng: 139.6503 } },
      rating: 4.0,
      user_ratings_total: 890,
      types: ['transit_station'],
    }
  ];
  
  return mockResults.filter(place => 
    place.name.toLowerCase().includes(query.toLowerCase())
  );
};
```

---

### **å®Ÿè£…å„ªå…ˆé †ä½**

#### **Phase 1: ã‚³ã‚¢æ©Ÿèƒ½ (Week 1)**
1. **PlaceSearchInputå…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä½œæˆ**
2. **PlaceSearchServiceçµ±åˆ**
3. **Create Trip: Departure & Destination Inputæ”¹ä¿®**

#### **Phase 2: ãƒ“ãƒ¥ãƒ¼çµ±åˆ (Week 2)**
4. **Map View Searchçµ±åˆ**
5. **My Places Searchçµ±åˆ**
6. **çµ±ä¸€AddPlaceDetailãƒšãƒ¼ã‚¸ä½œæˆ**

#### **Phase 3: é«˜åº¦ãªæ©Ÿèƒ½ (Week 3)**
7. **List View & Calendar View Modalçµ±åˆ** 
8. **ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã®å¼•ãç¶™ã**
9. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° & ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**

#### **Phase 4: æœ€é©åŒ– (Week 4)**
10. **æ¤œç´¢çµæœã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥**
11. **åœ°ç†çš„åˆ¶ç´„ã®é©ç”¨**
12. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**

ã“ã®çµ±ä¸€ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®å ´æ‰€å…¥åŠ›ã§ä¸€è²«ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã¨ã€ä¿¡é ¼æ€§ã®é«˜ã„Google Maps APIçµ±åˆãŒå®Ÿç¾ã•ã‚Œã¾ã™ã€‚

---

## ğŸ“Š **ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ãƒ•ãƒ­ãƒ¼è©³ç´°**

### **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å…¥åŠ› â†’ Supabase â†’ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  â†’ Supabase â†’ 3å½¢å¼è¡¨ç¤º**

#### **Phase 1: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å…¥åŠ›**
```typescript
// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå ´æ‰€ã‚’è¿½åŠ 
interface PlaceInput {
  name: string;
  latitude: number;
  longitude: number;
  category: string;
  wish_level: 1 | 2 | 3 | 4 | 5;  // å¸Œæœ›åº¦
  stay_duration_minutes: number;
  // Google Maps API ã‹ã‚‰å–å¾—ã•ã‚Œã‚‹è¿½åŠ ãƒ‡ãƒ¼ã‚¿
  google_place_id?: string;
  google_rating?: number;
  // ...
}

// å€‹äººå¸Œæœ›åœ°ã¨ã—ã¦Supabaseã«ä¿å­˜
const addPersonalPlace = async (placeData: PlaceInput) => {
  await supabase.from('places').insert({
    ...placeData,
    trip_id: currentTripId,
    user_id: currentUserId,
    scheduled: false, // å€‹äººå¸Œæœ›åœ°
    source: 'user'
  });
};
```

#### **Phase 2: Supabaseä¿å­˜ (å€‹äººå¸Œæœ›åœ°)**
```sql
-- å€‹äººå¸Œæœ›åœ°ã¨ã—ã¦ä¿å­˜ã•ã‚Œã‚‹ãƒ¬ã‚³ãƒ¼ãƒ‰
INSERT INTO places (
  trip_id,        -- 'abc-123-def'
  user_id,        -- 'user-456-ghi' 
  name,           -- 'æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼'
  scheduled,      -- false (å€‹äººå¸Œæœ›åœ°)
  wish_level,     -- 4
  stay_duration_minutes, -- 120
  -- ...
);
```

#### **Phase 3: æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œ**
```typescript
// Edge Function: trip-optimization
const optimizationInput = {
  tripId: string;
  settings: {
    fairness_weight: 0.6;    // å…¬å¹³æ€§é‡ã¿
    efficiency_weight: 0.4;  // ãƒ«ãƒ¼ãƒˆåŠ¹ç‡é‡ã¿
    max_places: 10;         // æœ€å¤§æ¡ç”¨å ´æ‰€æ•°
    max_daily_hours: 8;     // 1æ—¥æœ€å¤§æ™‚é–“
  }
};

// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å‡¦ç†
const result = await optimizeTrip(optimizationInput);
```

#### **Phase 4: æœ€é©åŒ–çµæœSupabaseä¿å­˜**
```sql
-- 1. æœ€é©åŒ–çµæœä¿å­˜
INSERT INTO optimization_results (
  trip_id,
  optimized_route,    -- JSON: æ—¥åˆ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« + ã‚«ãƒ©ãƒ¼æƒ…å ±
  optimization_score, -- JSON: å…¬å¹³æ€§ãƒ»åŠ¹ç‡æ€§ã‚¹ã‚³ã‚¢
  is_active          -- true (ç¾åœ¨é©ç”¨ä¸­)
);

-- 2. æ¡ç”¨å ´æ‰€ã‚’scheduled=trueã«æ›´æ–°
UPDATE places 
SET scheduled = true, 
    scheduled_date = '2024-01-15',
    scheduled_time_start = '10:00'
WHERE id IN (æ¡ç”¨ã•ã‚ŒãŸå ´æ‰€ã®IDãƒªã‚¹ãƒˆ);
```

#### **Phase 5: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é…ä¿¡**
```typescript
// Supabase Realtime ã§å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é…ä¿¡
supabase
  .channel('trip_updates')
  .on('postgres_changes', {
    event: 'UPDATE',
    schema: 'public',
    table: 'places',
    filter: `trip_id=eq.${tripId}`
  }, (payload) => {
    // æœ€é©åŒ–çµæœã‚’å—ä¿¡ã—ã¦UIæ›´æ–°
    updateOptimizationDisplay(payload);
  });
```

#### **Phase 6: 3å½¢å¼ã§ã®è¡¨ç¤º**
```typescript
// å…±é€šã®æœ€é©åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’3ã¤ã®å½¢å¼ã§è¡¨ç¤º
interface OptimizedPlace {
  id: string;
  name: string;
  member_colors: string[];  // è²¢çŒ®ãƒ¡ãƒ³ãƒãƒ¼ã®è‰²é…åˆ—
  display_color: string;    // æœ€çµ‚è¡¨ç¤ºè‰²
  order: number;           // è¨ªå•é †åº
  scheduled_time: string;  // äºˆå®šæ™‚åˆ»
}

// Map View ã§ã®è¡¨ç¤º
const MapView = ({ places }: { places: OptimizedPlace[] }) => {
  return places.map(place => (
    <GoogleMapMarker
      position={{ lat: place.latitude, lng: place.longitude }}
      color={place.display_color}  // ãƒ¡ãƒ³ãƒãƒ¼ã‚«ãƒ©ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯é©ç”¨
      label={place.order.toString()}
    />
  ));
};

// Timeline View ã§ã®è¡¨ç¤º
const TimelineView = ({ places }: { places: OptimizedPlace[] }) => {
  return (
    <div className="timeline">
      {places.map(place => (
        <PlaceCard
          key={place.id}
          backgroundColor={place.display_color}
          time={place.scheduled_time}
          name={place.name}
        />
      ))}
    </div>
  );
};

// Calendar View ã§ã®è¡¨ç¤º
const CalendarView = ({ places }: { places: OptimizedPlace[] }) => {
  const groupedByDate = groupPlacesByDate(places);
  return Object.entries(groupedByDate).map(([date, dayPlaces]) => (
    <CalendarDay key={date} date={date}>
      {dayPlaces.map(place => (
        <CalendarTimeSlot
          time={place.scheduled_time}
          backgroundColor={place.display_color}
          content={place.name}
        />
      ))}
    </CalendarDay>
  ));
};
```

---

## ğŸ§® **æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è©³ç´°**

### **åŒæ–¹å‘ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ **

#### **1. å…¬å¹³æ€§ã‚¹ã‚³ã‚¢è¨ˆç®—**
```typescript
interface FairnessAnalysis {
  memberPlaceCounts: Record<string, number>;  // ãƒ¡ãƒ³ãƒãƒ¼åˆ¥æ¡ç”¨å ´æ‰€æ•°
  memberWishLevels: Record<string, number[]>; // ãƒ¡ãƒ³ãƒãƒ¼åˆ¥å¸Œæœ›åº¦
  deviation: number;                          // åå·®
  fairnessScore: number;                     // 0-100
}

const calculateFairnessScore = (selectedPlaces: Place[], members: User[]): FairnessAnalysis => {
  // å„ãƒ¡ãƒ³ãƒãƒ¼ã®æ¡ç”¨å ´æ‰€æ•°ã‚’è¨ˆç®—
  const memberCounts = members.reduce((acc, member) => {
    acc[member.id] = selectedPlaces.filter(p => p.user_id === member.id).length;
    return acc;
  }, {} as Record<string, number>);
  
  // æ¨™æº–åå·®ã‚’è¨ˆç®—
  const counts = Object.values(memberCounts);
  const mean = counts.reduce((a, b) => a + b, 0) / counts.length;
  const variance = counts.reduce((acc, count) => acc + Math.pow(count - mean, 2), 0) / counts.length;
  const standardDeviation = Math.sqrt(variance);
  
  // å…¬å¹³æ€§ã‚¹ã‚³ã‚¢ (åå·®ãŒå°ã•ã„ã»ã©é«˜ã‚¹ã‚³ã‚¢)
  const fairnessScore = Math.max(0, 100 - (standardDeviation * 20));
  
  return {
    memberPlaceCounts: memberCounts,
    memberWishLevels: calculateWishLevels(selectedPlaces, members),
    deviation: standardDeviation,
    fairnessScore
  };
};
```

#### **2. ãƒ«ãƒ¼ãƒˆåŠ¹ç‡ã‚¹ã‚³ã‚¢è¨ˆç®—**
```typescript
interface EfficiencyAnalysis {
  totalDistance: number;        // ç·ç§»å‹•è·é›¢
  totalTravelTime: number;      // ç·ç§»å‹•æ™‚é–“
  routeOptimality: number;      // ãƒ«ãƒ¼ãƒˆæœ€é©æ€§
  timeUtilization: number;      // æ™‚é–“åˆ©ç”¨åŠ¹ç‡
  efficiencyScore: number;      // 0-100
}

const calculateEfficiencyScore = (route: Place[]): EfficiencyAnalysis => {
  // TSPã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§æœ€é©ãƒ«ãƒ¼ãƒˆã‚’è¨ˆç®—
  const optimizedRoute = solveTSP(route);
  const currentRoute = route;
  
  // è·é›¢åŠ¹ç‡è¨ˆç®—
  const optimalDistance = calculateTotalDistance(optimizedRoute);
  const currentDistance = calculateTotalDistance(currentRoute);
  const routeOptimality = (optimalDistance / currentDistance) * 100;
  
  // æ™‚é–“åŠ¹ç‡è¨ˆç®—
  const totalStayTime = route.reduce((acc, place) => acc + place.stay_duration_minutes, 0);
  const totalTravelTime = calculateTotalTravelTime(currentRoute);
  const timeUtilization = (totalStayTime / (totalStayTime + totalTravelTime)) * 100;
  
  // åŠ¹ç‡ã‚¹ã‚³ã‚¢
  const efficiencyScore = (routeOptimality * 0.6) + (timeUtilization * 0.4);
  
  return {
    totalDistance: currentDistance,
    totalTravelTime,
    routeOptimality,
    timeUtilization,
    efficiencyScore
  };
};
```

#### **3. çµ±åˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°**
```typescript
interface OptimizationScore {
  fairness: FairnessAnalysis;
  efficiency: EfficiencyAnalysis;
  combinedScore: number;
  recommendation: string;
}

const calculateCombinedScore = (
  places: Place[], 
  members: User[], 
  settings: OptimizationSettings
): OptimizationScore => {
  const fairness = calculateFairnessScore(places, members);
  const efficiency = calculateEfficiencyScore(places);
  
  // é‡ã¿ä»˜ãçµ±åˆã‚¹ã‚³ã‚¢
  const combinedScore = 
    (fairness.fairnessScore * settings.fairness_weight) +
    (efficiency.efficiencyScore * settings.efficiency_weight);
  
  // æ¨å¥¨äº‹é …ç”Ÿæˆ
  const recommendation = generateRecommendation(fairness, efficiency);
  
  return {
    fairness,
    efficiency,
    combinedScore,
    recommendation
  };
};
```

#### **4. åˆ¶ç´„è€ƒæ…®é¸æŠã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **
```typescript
const selectOptimalPlaces = async (
  tripId: string, 
  settings: OptimizationSettings
): Promise<OptimizationResult> => {
  // 1. å…¨å€‹äººå¸Œæœ›åœ°ã‚’å–å¾—
  const personalWishes = await getPersonalWishPlaces(tripId);
  
  // 2. å¿…é ˆå ´æ‰€ã‚’å…ˆã«ç¢ºå®š (departure + destination)
  const mandatoryPlaces = await getMandatoryPlaces(tripId);
  
  // 3. åœ°ç†çš„åˆ¶ç´„ãƒã‚§ãƒƒã‚¯
  const feasiblePlaces = await filterByGeographicConstraints(personalWishes);
  
  // 4. å€™è£œçµ„ã¿åˆã‚ã›ç”Ÿæˆ
  const combinations = generatePlaceCombinations(
    feasiblePlaces, 
    settings.max_places - mandatoryPlaces.length
  );
  
  // 5. å„çµ„ã¿åˆã‚ã›ã‚’è©•ä¾¡
  let bestCombination = null;
  let bestScore = 0;
  
  for (const combination of combinations) {
    const fullRoute = [...mandatoryPlaces, ...combination];
    const score = calculateCombinedScore(fullRoute, members, settings);
    
    if (score.combinedScore > bestScore) {
      bestScore = score.combinedScore;
      bestCombination = combination;
    }
  }
  
  return {
    selectedPlaces: [...mandatoryPlaces, ...bestCombination],
    score: bestScore,
    analysis: calculateDetailedAnalysis(bestCombination)
  };
};
```

#### **5. ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹å¯¾å¿œ**
```typescript
const handleEdgeCases = (places: Place[], members: User[]): Place[] => {
  // ã‚±ãƒ¼ã‚¹1: ä¸€äººã‚‚å ´æ‰€ã‚’è¿½åŠ ã—ã¦ã„ãªã„
  if (places.length === 0) {
    return generateDefaultPlaces(tripId); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¦³å…‰åœ°ã‚’ææ¡ˆ
  }
  
  // ã‚±ãƒ¼ã‚¹2: ä¸€äººã ã‘ãŒå¤§é‡ã«è¿½åŠ 
  const placesPerMember = groupBy(places, 'user_id');
  const contributions = Object.values(placesPerMember).map(p => p.length);
  const maxContribution = Math.max(...contributions);
  const avgContribution = contributions.reduce((a, b) => a + b, 0) / contributions.length;
  
  if (maxContribution > avgContribution * 3) {
    // æœ€å¤§è²¢çŒ®è€…ã®å ´æ‰€ã‚’ä¸€éƒ¨åˆ¶é™
    return limitSingleUserContribution(places, maxContribution);
  }
  
  // ã‚±ãƒ¼ã‚¹3: å…¨ã¦åŒã˜wish_level (1 or 5)
  const uniqueWishLevels = [...new Set(places.map(p => p.wish_level))];
  if (uniqueWishLevels.length === 1) {
    // ä»–ã®è¦ç´ ã§å„ªå…ˆåº¦ä»˜ã‘ (rating, stay_durationç­‰)
    return prioritizeByAlternativeFactors(places);
  }
  
  // ã‚±ãƒ¼ã‚¹4: å…¨ã¦must_visit (wish_level = 5)
  const mustVisitCount = places.filter(p => p.wish_level === 5).length;
  if (mustVisitCount > settings.max_places) {
    // åœ°ç†çš„åŠ¹ç‡æ€§ã§çµã‚Šè¾¼ã¿
    return selectByGeographicEfficiency(places);
  }
  
  return places;
};
```

---

## ğŸ¨ **ãƒ¡ãƒ³ãƒãƒ¼ã‚«ãƒ©ãƒ¼ã‚·ã‚¹ãƒ†ãƒ è©³ç´°**

### **20è‰²ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ**
```typescript
const MEMBER_COLORS = [
  { id: 1, name: 'Coral Red', hex: '#FF6B6B', rgb: 'rgb(255, 107, 107)' },
  { id: 2, name: 'Ocean Blue', hex: '#4ECDC4', rgb: 'rgb(78, 205, 196)' },
  { id: 3, name: 'Sunset Orange', hex: '#FFE66D', rgb: 'rgb(255, 230, 109)' },
  { id: 4, name: 'Forest Green', hex: '#95E1D3', rgb: 'rgb(149, 225, 211)' },
  { id: 5, name: 'Royal Purple', hex: '#A8E6CF', rgb: 'rgb(168, 230, 207)' },
  // ... æ®‹ã‚Š15è‰²
  { id: 20, name: 'Midnight Blue', hex: '#2C3E50', rgb: 'rgb(44, 62, 80)' }
] as const;
```

### **ã‚«ãƒ©ãƒ¼å‰²ã‚Šå½“ã¦ãƒ­ã‚¸ãƒƒã‚¯**
```typescript
const assignMemberColors = async (tripId: string): Promise<ColorAssignment[]> => {
  const members = await getTripMembers(tripId);
  const assignments: ColorAssignment[] = [];
  
  members.forEach((member, index) => {
    assignments.push({
      userId: member.id,
      colorIndex: index + 1, // 1-20
      color: MEMBER_COLORS[index],
      assignedAt: new Date()
    });
  });
  
  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
  await saveMemberColorAssignments(tripId, assignments);
  return assignments;
};
```

### **å ´æ‰€ã‚«ãƒ©ãƒ¼è¨ˆç®—**
```typescript
interface PlaceColorLogic {
  calculatePlaceColor(place: Place, contributors: User[]): PlaceColorResult;
}

const calculatePlaceColor = (place: Place, contributors: User[]): PlaceColorResult => {
  const contributorCount = contributors.length;
  
  if (contributorCount === 1) {
    // å˜ä¸€ãƒ¡ãƒ³ãƒãƒ¼: ãã®ãƒ¡ãƒ³ãƒãƒ¼ã®è‰²
    return {
      type: 'single',
      primaryColor: contributors[0].assignedColor,
      cssStyle: `background-color: ${contributors[0].assignedColor}`
    };
  }
  
  if (contributorCount >= 2 && contributorCount <= 4) {
    // 2-4äºº: ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const colors = contributors.map(c => c.assignedColor);
    return {
      type: 'gradient',
      colors: colors,
      cssStyle: `background: linear-gradient(45deg, ${colors.join(', ')})`
    };
  }
  
  if (contributorCount >= 5) {
    // 5äººä»¥ä¸Š: é‡‘è‰²
    return {
      type: 'gold',
      primaryColor: '#FFD700', // Gold
      cssStyle: `background: linear-gradient(45deg, #FFD700, #FFA500)`
    };
  }
  
  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ (è²¢çŒ®è€…ãªã—)
  return {
    type: 'unassigned',
    primaryColor: '#E0E0E0', // Gray
    cssStyle: `background-color: #E0E0E0`
  };
};
```

---

## ğŸ–¥ï¸ **UIè¡¨ç¤ºæ–¹æ³•è©³ç´°**

### **Map View ã§ã®è‰²è¡¨ç¤º**
```typescript
const MapViewMarker = ({ place, contributors }: MapMarkerProps) => {
  const colorResult = calculatePlaceColor(place, contributors);
  
  // Google Maps ãƒãƒ¼ã‚«ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
  const markerIcon = {
    path: google.maps.SymbolPath.CIRCLE,
    fillColor: colorResult.primaryColor,
    fillOpacity: 1,
    strokeColor: '#FFFFFF',
    strokeWeight: 2,
    scale: 8
  };
  
  // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®å ´åˆã¯ç‰¹åˆ¥ãªã‚¢ã‚¤ã‚³ãƒ³
  if (colorResult.type === 'gradient') {
    return (
      <CustomGradientMarker
        position={{ lat: place.latitude, lng: place.longitude }}
        colors={colorResult.colors}
        label={place.order?.toString()}
      />
    );
  }
  
  return (
    <GoogleMapMarker
      position={{ lat: place.latitude, lng: place.longitude }}
      icon={markerIcon}
      title={place.name}
    />
  );
};
```

### **Timeline View ã§ã®è‰²è¡¨ç¤º**
```typescript
const TimelineCard = ({ place, contributors }: TimelineCardProps) => {
  const colorResult = calculatePlaceColor(place, contributors);
  
  return (
    <div 
      className="timeline-card"
      style={{
        background: colorResult.cssStyle,
        border: `2px solid ${colorResult.primaryColor}`,
        borderRadius: '8px',
        padding: '16px',
        margin: '8px 0'
      }}
    >
      <div className="card-header">
        <h3 className="place-name">{place.name}</h3>
        <span className="visit-time">{place.scheduled_time}</span>
      </div>
      
      <div className="contributors">
        {contributors.map(contributor => (
          <div 
            key={contributor.id}
            className="contributor-badge"
            style={{ backgroundColor: contributor.assignedColor }}
          >
            {contributor.name}
          </div>
        ))}
      </div>
      
      <div className="place-details">
        <p>æ»åœ¨æ™‚é–“: {place.stay_duration_minutes}åˆ†</p>
        <p>å¸Œæœ›åº¦: {'â˜…'.repeat(place.wish_level)}</p>
      </div>
    </div>
  );
};
```

### **Calendar View ã§ã®è‰²è¡¨ç¤º**
```typescript
const CalendarTimeSlot = ({ place, contributors, timeSlot }: CalendarSlotProps) => {
  const colorResult = calculatePlaceColor(place, contributors);
  
  return (
    <div 
      className="calendar-time-slot"
      style={{
        background: colorResult.cssStyle,
        height: `${place.stay_duration_minutes / 10}px`, // 10åˆ† = 1px
        minHeight: '30px',
        borderRadius: '4px',
        padding: '4px',
        margin: '2px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'white',
        textShadow: '1px 1px 1px rgba(0,0,0,0.5)',
        fontSize: '12px',
        fontWeight: 'bold'
      }}
    >
      <span className="place-name-short">
        {place.name.length > 15 ? place.name.substring(0, 12) + '...' : place.name}
      </span>
    </div>
  );
};

const CalendarDay = ({ date, places }: CalendarDayProps) => {
  const timeSlots = generateTimeSlots(6, 22); // 6:00-22:00
  
  return (
    <div className="calendar-day">
      <div className="day-header">
        <h3>{format(date, 'Mæœˆdæ—¥ (E)', { locale: ja })}</h3>
      </div>
      
      <div className="time-grid">
        {timeSlots.map(timeSlot => {
          const placesInSlot = places.filter(place => 
            isTimeInSlot(place.scheduled_time, timeSlot)
          );
          
          return (
            <div key={timeSlot} className="time-row">
              <div className="time-label">{timeSlot}</div>
              <div className="time-content">
                {placesInSlot.map(place => (
                  <CalendarTimeSlot
                    key={place.id}
                    place={place}
                    contributors={getPlaceContributors(place)}
                    timeSlot={timeSlot}
                  />
                ))}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

### **çµ±ä¸€ã‚«ãƒ©ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **
```typescript
// å…¨è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã§ä½¿ç”¨ã™ã‚‹çµ±ä¸€ã‚«ãƒ©ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
class ColorManager {
  private memberColors: Map<string, string> = new Map();
  private placeColors: Map<string, PlaceColorResult> = new Map();
  
  async initializeColors(tripId: string) {
    // ãƒ¡ãƒ³ãƒãƒ¼ã‚«ãƒ©ãƒ¼èª­ã¿è¾¼ã¿
    const memberAssignments = await getMemberColorAssignments(tripId);
    memberAssignments.forEach(assignment => {
      this.memberColors.set(assignment.userId, assignment.color.hex);
    });
    
    // å ´æ‰€ã‚«ãƒ©ãƒ¼è¨ˆç®—ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    const places = await getOptimizedPlaces(tripId);
    for (const place of places) {
      const contributors = await getPlaceContributors(place.id);
      const colorResult = calculatePlaceColor(place, contributors);
      this.placeColors.set(place.id, colorResult);
    }
  }
  
  getPlaceColor(placeId: string): PlaceColorResult {
    return this.placeColors.get(placeId) || DEFAULT_COLOR;
  }
  
  getMemberColor(userId: string): string {
    return this.memberColors.get(userId) || DEFAULT_MEMBER_COLOR;
  }
  
  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°å¯¾å¿œ
  updatePlaceColor(placeId: string, contributors: User[]) {
    const place = getPlace(placeId);
    const colorResult = calculatePlaceColor(place, contributors);
    this.placeColors.set(placeId, colorResult);
    
    // å…¨è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã«æ›´æ–°é€šçŸ¥
    this.notifyColorUpdate(placeId, colorResult);
  }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚«ãƒ©ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const colorManager = new ColorManager();
```

---

## ğŸ”„ **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸè©³ç´°**

### **Supabase Realtimeçµ±åˆ**
```typescript
// æœ€é©åŒ–çµæœã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é…ä¿¡
const setupOptimizationRealtimeSync = (tripId: string) => {
  const supabase = createClient(supabaseUrl, supabaseKey);
  
  // æœ€é©åŒ–çµæœã®å¤‰æ›´ã‚’ç›£è¦–
  supabase
    .channel(`optimization_${tripId}`)
    .on('postgres_changes', {
      event: '*',
      schema: 'public',
      table: 'optimization_results',
      filter: `trip_id=eq.${tripId}`
    }, async (payload) => {
      if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
        // æ–°ã—ã„æœ€é©åŒ–çµæœã‚’å—ä¿¡
        const newResult = payload.new as OptimizationResult;
        
        // å…¨è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã‚’æ›´æ–°
        await updateAllDisplayModes(newResult);
        
        // ã‚«ãƒ©ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼æ›´æ–°
        await colorManager.initializeColors(tripId);
        
        // UIå†æç”»
        triggerUIUpdate();
      }
    })
    .subscribe();
  
  // å ´æ‰€ã®å¤‰æ›´ã‚‚ç›£è¦–
  supabase
    .channel(`places_${tripId}`)
    .on('postgres_changes', {
      event: '*',
      schema: 'public', 
      table: 'places',
      filter: `trip_id=eq.${tripId}`
    }, async (payload) => {
      // å ´æ‰€ã®è¿½åŠ ãƒ»å‰Šé™¤ãƒ»æ›´æ–°æ™‚ã«è‡ªå‹•å†æœ€é©åŒ–
      if (payload.eventType === 'INSERT') {
        await triggerAutoOptimization(tripId);
      }
    })
    .subscribe();
};
```

---

## ğŸ“‹ **å®Ÿè£…æº–å‚™å®Œäº†ç¢ºèªäº‹é …**

### **âœ… ç¢ºèªæ¸ˆã¿**
1. **Google Maps API**: å˜ä¸€ã‚­ãƒ¼ã§å…¨æ©Ÿèƒ½æä¾›ç¢ºèª
2. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹é€ **: placesãƒ†ãƒ¼ãƒ–ãƒ«ãŒtrip_id + user_idå¯¾å¿œæ¸ˆã¿
3. **ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è¦ä»¶**: å…¬å¹³æ€§ï¼‹åŠ¹ç‡æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°è¨­è¨ˆå®Œäº†
4. **departure/destination**: å¿…é ˆé…ç½®ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆå®Œäº†
5. **ãƒ¡ãƒ³ãƒãƒ¼ã‚«ãƒ©ãƒ¼**: 20è‰²ã‚·ã‚¹ãƒ†ãƒ  + 3è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰çµ±åˆè¨­è¨ˆå®Œäº†
6. **ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹**: å…¨å¯¾å¿œã‚·ãƒŠãƒªã‚ªè¨­è¨ˆå®Œäº†
7. **ã‚µãƒ¼ãƒãƒ¼ãƒ™ãƒ¼ã‚¹**: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®Œå…¨æ’é™¤ç¢ºèª
8. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ•´åˆæ€§**: ç¾åœ¨ã®Supabaseã‚¹ã‚­ãƒ¼ãƒã¨ä¸€è²«æ€§ç¢ºèª

### **ğŸš¨ å®Ÿè£…å‰æœ€çµ‚ç¢ºèªé …ç›®**
- [ ] Supabase MCPã§ã®ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹é€ è©³ç´°ç¢ºèª
- [ ] æ—¢å­˜ã®placesãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®å½±éŸ¿ç¯„å›²ç¢ºèª
- [ ] æ—¢å­˜ã®æœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆæ–¹æ³•ç¢ºèª
- [ ] ç¾åœ¨ã®UIè¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã¨ã®æ•´åˆæ€§ç¢ºèª

**ã“ã®è©³ç´°è¨­è¨ˆã«åŸºã¥ã„ã¦å®Ÿè£…ã‚’é–‹å§‹ã™ã‚‹æº–å‚™ãŒæ•´ã„ã¾ã—ãŸã€‚**
