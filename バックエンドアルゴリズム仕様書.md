# Voypath バックエンド・アルゴリズム仕様書

## 1. システム全体構成
実装は全て英語で行うこと
### 1.1 アーキテクチャ概要
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │    Supabase     │    │   External      │
│   (Vercel)      │    │   Backend       │    │   Services      │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ React + TS  │ │◄──►│ │ PostgreSQL  │ │    │ │   Stripe    │ │
│ │ Zustand     │ │    │ │ + RLS       │ │    │ │             │ │
│ │ Tailwind    │ │    │ └─────────────┘ │    │ └─────────────┘ │
│ │ Framer      │ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ └─────────────┘ │    │ │ Edge        │ │◄──►│ │ Google Maps │ │
│                 │    │ │ Functions   │ │    │ │ (Optional)  │ │
└─────────────────┘    │ │ (Deno TS)   │ │    │ └─────────────┘ │
                       │ └─────────────┘ │    │ ┌─────────────┐ │
                       │ ┌─────────────┐ │    │ │   Pexels    │ │
                       │ │ Auth +      │ │    │ │  (Images)   │ │
                       │ │ Realtime    │ │    │ └─────────────┘ │
                       │ └─────────────┘ │    └─────────────────┘
                       └─────────────────┘
```

### 1.2 技術スタック
- **Frontend**: React 18 + TypeScript + Vite (Vercel)
- **Backend**: Supabase PostgreSQL + Edge Functions (Deno)
- **Authentication**: Supabase Auth (JWT)
- **Real-time**: Supabase Realtime (WebSocket)
- **Storage**: Supabase Storage (画像・ファイル)
- **Payment**: Stripe (サブスクリプション)
- **Maps**: Google Maps API (オプション)
- **Images**: Pexels API (プレースホルダー)

### 1.3 データフロー原則
1. **クライアントサイド**: 状態管理のみ、データ永続化なし
2. **サーバーサイド**: 全データの永続化・管理
3. **リアルタイム同期**: Supabase Realtime経由での即座反映
4. **セキュリティ**: RLS（Row Level Security）による厳密なアクセス制御

## 2. Supabase Edge Functions仕様

### 2.1 Edge Functions 一覧

#### 2.1.1 決済関連
```typescript
// supabase/functions/create-checkout-session/index.ts
interface CreateCheckoutSessionRequest {
  priceId: string;
  userId: string;
  successUrl: string;
  cancelUrl: string;
}

interface CreateCheckoutSessionResponse {
  sessionId: string;
  url: string;
}
```

#### 2.1.2 最適化エンジン
```typescript
// supabase/functions/optimize-route/index.ts
interface OptimizeRouteRequest {
  tripId: string;
  userId: string;
  settings?: OptimizationSettings;
}

interface OptimizeRouteResponse {
  optimizedRoute: OptimizedRoute;
  optimizationScore: OptimizationScore;
  executionTime: number;
}
```

#### 2.1.3 Webhook処理
```typescript
// supabase/functions/stripe-webhook/index.ts
interface WebhookEvent {
  type: string;
  data: {
    object: any;
  };
}
```

### 2.2 Edge Functions 共通構造

#### 2.2.1 基本テンプレート
```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // CORS対応
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Supabase クライアント初期化
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    );

    // リクエスト処理
    const requestData = await req.json();
    const result = await processRequest(requestData, supabaseClient);

    return new Response(
      JSON.stringify(result),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});
```

## 3. ルート最適化アルゴリズム

### 3.1 アルゴリズム全体フロー

#### 3.1.1 メイン処理関数
```typescript
export async function optimizeRoute(tripId: string, supabase: SupabaseClient): Promise<OptimizedRoute> {
  // Step 1: データ収集
  const { places, trip, members } = await gatherTripData(tripId, supabase);
  
  // Step 2: 前処理とバリデーション
  const validatedPlaces = await preprocessPlaces(places, trip);
  
  // Step 3: ユーザー重み正規化
  const normalizedPlaces = normalizeUserWeights(validatedPlaces, members);
  
  // Step 4: 地理的クラスタリング
  const clusteredPlaces = clusterPlacesByDay(normalizedPlaces, trip);
  
  // Step 5: 営業時間制約チェック
  const feasiblePlaces = await validateOperatingHours(clusteredPlaces);
  
  // Step 6: 最適化実行
  const optimizedOrder = optimizeByIntegratedScore(feasiblePlaces);
  
  // Step 7: 詳細スケジュール生成
  const detailedSchedule = createDetailedSchedule(optimizedOrder, trip);
  
  // Step 8: 結果保存とリアルタイム配信
  await saveAndBroadcastResults(tripId, detailedSchedule, supabase);
  
  return detailedSchedule;
}
```

#### 3.1.2 データ収集
```typescript
async function gatherTripData(tripId: string, supabase: SupabaseClient) {
  // 旅行基本情報取得
  const { data: trip, error: tripError } = await supabase
    .from('trips')
    .select('*')
    .eq('id', tripId)
    .single();

  if (tripError) throw new Error(`Trip not found: ${tripError.message}`);
  
  // departure_locationが必須であることを確認
  if (!trip.departure_location) {
    throw new Error('Departure location is required for optimization');
  }

  // 場所データ取得
  let places = [];
  
  if (trip.start_date && trip.end_date) {
    // 日程が確定している場合、通常の場所データを取得
    const { data: tripPlaces, error: placesError } = await supabase
      .from('places')
      .select(`
        *,
        user:users(id, name, is_premium)
      `)
      .eq('trip_id', tripId)
      .order('created_at');
      
    if (placesError) throw new Error(`Failed to fetch places: ${placesError.message}`);
    places = tripPlaces || [];
  } else {
    // 日程未確定の場合、すべてのユーザーmy placesを取得
    places = await getAllUserPlacesForTrip(tripId, supabase);
  }
  
  // 出発地を仮想的な最初の場所として追加
  const departurePlace = {
    id: 'departure',
    name: trip.departure_location,
    category: 'departure_point',
    latitude: null, // geocodingが必要
    longitude: null, // geocodingが必要
    is_departure: true,
    stay_duration_minutes: 0,
    wish_level: 5, // 必須訪問地点
    user_id: trip.owner_id,
    trip_id: tripId
  };
  
  // 目的地処理ロジック
  let destinationPlace = null;
  if (trip.destination && trip.destination !== trip.departure_location) {
    // 目的地が出発地と異なる場合、最終目的地として追加
    destinationPlace = {
      id: 'destination',
      name: trip.destination,
      category: 'destination_point',
      latitude: null, // geocodingが必要
      longitude: null, // geocodingが必要
      is_destination: true,
      stay_duration_minutes: 60,
      wish_level: 5, // 必須訪問地点
      user_id: trip.owner_id,
      trip_id: tripId,
      visit_date: trip.end_date, // 最終日に自動配置
      scheduled: trip.end_date ? true : false,
      scheduled_date: trip.end_date
    };
  } else {
    // 目的地が出発地と同じ場合、出発地への帰還として追加
    destinationPlace = {
      id: 'return_to_departure',
      name: trip.departure_location + ' (Return)',
      category: 'return_point',
      latitude: null, // geocodingが必要
      longitude: null, // geocodingが必要
      is_return: true,
      stay_duration_minutes: 0,
      wish_level: 5, // 必須訪問地点
      user_id: trip.owner_id,
      trip_id: tripId,
      visit_date: trip.end_date, // 最終日に自動配置
      scheduled: trip.end_date ? true : false,
      scheduled_date: trip.end_date
    };
  }
  
  // placesリストに出発地と目的地を追加
  places = [departurePlace, ...places];
  if (destinationPlace) {
    places.push(destinationPlace);
  }

  // メンバー情報取得
  const { data: members, error: membersError } = await supabase
    .from('trip_members')
    .select(`
      *,
      user:users(id, name, is_premium)
    `)
    .eq('trip_id', tripId);

  if (membersError) throw new Error(`Failed to fetch members: ${membersError.message}`);

  return { trip, places, members, departure: departurePlace, destination: destinationPlace };
}

// 日程未確定時の全ユーザーmy places取得関数
async function getAllUserPlacesForTrip(tripId: string, supabase: SupabaseClient) {
  // 旅行メンバーを取得
  const { data: members, error: membersError } = await supabase
    .from('trip_members')
    .select('user_id')
    .eq('trip_id', tripId);
    
  if (membersError) throw new Error(`Failed to fetch members: ${membersError.message}`);
  
  const userIds = members.map(m => m.user_id);
  
  // 全ユーザーのmy placesを取得（trip_idに関係なく）
  const { data: allUserPlaces, error: placesError } = await supabase
    .from('places')
    .select(`
      *,
      user:users(id, name, is_premium)
    `)
    .in('user_id', userIds)
    .order('created_at');
    
  if (placesError) throw new Error(`Failed to fetch user places: ${placesError.message}`);
  
  return allUserPlaces || [];
}
```

### 3.2 正規化アルゴリズム

#### 3.2.1 出発地・目的地考慮最適化
```typescript
// 出発地と目的地を考慮したルート最適化
function optimizeRouteWithDepartureAndDestination(
  places: NormalizedPlace[], 
  departure: Place, 
  destination: Place | null
): NormalizedPlace[] {
  // 出発地と目的地を除いた中間地点を取得
  const intermediatePlaces = places.filter(p => 
    p.id !== 'departure' && 
    p.id !== 'destination' && 
    p.id !== 'return_to_departure'
  );
  
  if (!destination) {
    // 目的地がない場合は従来のロジック
    const optimalOrder = solveTSPWithFixedStart(departure, intermediatePlaces);
    return [departure, ...optimalOrder];
  }
  
  // 出発地→中間地点→目的地の最適ルート計算（TSP with fixed start and end）
  const optimalOrder = solveTSPWithFixedStartAndEnd(departure, intermediatePlaces, destination);
  
  return optimalOrder;
}

// 出発地・目的地固定制約付きTSP解法
function solveTSPWithFixedStartAndEnd(
  startPoint: Place, 
  intermediatePlaces: Place[], 
  endPoint: Place
): Place[] {
  if (intermediatePlaces.length === 0) {
    return [startPoint, endPoint];
  }
  
  // 最近傍法による初期解（出発地→中間地点群→目的地）
  let currentPlace = startPoint;
  const unvisited = [...intermediatePlaces];
  const route: Place[] = [startPoint];
  
  while (unvisited.length > 0) {
    const nearest = findNearestPlace(currentPlace, unvisited);
    route.push(nearest);
    unvisited.splice(unvisited.indexOf(nearest), 1);
    currentPlace = nearest;
  }
  
  // 最後に目的地を追加
  route.push(endPoint);
  
  // 2-opt改善（開始点と終了点は固定）
  return improve2OptWithFixedEnds(route);
}

// 出発地固定制約付きTSP解法
function solveTSPWithFixedStart(startPoint: Place, places: Place[]): Place[] {
  // 最近傍法による初期解
  let currentPlace = startPoint;
  const unvisited = [...places];
  const route: Place[] = [];
  
  while (unvisited.length > 0) {
    const nearest = findNearestPlace(currentPlace, unvisited);
    route.push(nearest);
    unvisited.splice(unvisited.indexOf(nearest), 1);
    currentPlace = nearest;
  }
  
  // 2-opt改善
  return improve2Opt(route, startPoint);
}

function findNearestPlace(currentPlace: Place, candidates: Place[]): Place {
  let nearest = candidates[0];
  let minDistance = calculateHaversineDistance(currentPlace, nearest);
  
  for (const candidate of candidates.slice(1)) {
    const distance = calculateHaversineDistance(currentPlace, candidate);
    if (distance < minDistance) {
      minDistance = distance;
      nearest = candidate;
    }
  }
  
  return nearest;
}

function improve2OptWithFixedEnds(route: Place[]): Place[] {
  // 2-opt local search for improvement with fixed start and end points
  // 最初と最後の要素は固定し、中間地点のみを最適化
  if (route.length <= 3) return route; // 出発地、目的地、中間地点1つ以下は最適化不要
  
  let improved = true;
  let currentRoute = [...route];
  
  while (improved) {
    improved = false;
    
    // 最初と最後を除いた中間地点でのみ2-opt改善を試行
    for (let i = 1; i < currentRoute.length - 2; i++) {
      for (let j = i + 1; j < currentRoute.length - 1; j++) {
        const newRoute = [...currentRoute];
        
        // i から j までの区間を逆順にする
        const segment = newRoute.slice(i, j + 1).reverse();
        newRoute.splice(i, j - i + 1, ...segment);
        
        // 改善されたかチェック
        if (calculateTotalTravelDistance(newRoute) < calculateTotalTravelDistance(currentRoute)) {
          currentRoute = newRoute;
          improved = true;
        }
      }
    }
  }
  
  return currentRoute;
}

function improve2Opt(route: Place[], startPoint: Place): Place[] {
  // 2-opt local search for improvement (start point only fixed)
  // 実装の詳細は省略
  return route;
}
```

#### 3.2.2 ユーザー重み正規化
```typescript
interface NormalizedPlace extends Place {
  normalized_weight: number;
  user_place_count: number;
  fairness_factor: number;
}

function normalizeUserWeights(places: Place[], members: TripMember[]): NormalizedPlace[] {
  // ユーザーごとの場所数カウント
  const userPlaceCounts = places.reduce((acc, place) => {
    acc[place.user_id] = (acc[place.user_id] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // ユーザーごとの希望度分布取得
  const userWishLevels = groupBy(places, 'user_id');

  return places.map(place => {
    const userCount = userPlaceCounts[place.user_id];
    const userPlaces = userWishLevels[place.user_id];
    
    // ユーザー内希望度正規化 (1-5 → 1-5)
    const minWish = Math.min(...userPlaces.map(p => p.wish_level));
    const maxWish = Math.max(...userPlaces.map(p => p.wish_level));
    const normalizedWish = maxWish === minWish ? 3 : 
      1 + 4 * (place.wish_level - minWish) / (maxWish - minWish);

    // 公平性調整: 場所数が多いユーザーの重みを調整
    const baseWeight = 1 / userCount;
    const fairnessFactor = Math.sqrt(1 / userCount); // 場所数の平方根で調整
    
    // 最終重み計算
    const finalWeight = baseWeight * (normalizedWish / 3) * fairnessFactor;

    return {
      ...place,
      normalized_weight: finalWeight,
      user_place_count: userCount,
      fairness_factor: fairnessFactor
    };
  });
}
```

#### 3.2.2 エッジケース対応
```typescript
function handleEdgeCases(places: NormalizedPlace[]): NormalizedPlace[] {
  // Case 1: 希望度ゲーミング検出と対策
  const adjustedPlaces = adjustForWishLevelGaming(places);
  
  // Case 2: 最低採用保証
  const guaranteedPlaces = ensureMinimumAdoption(adjustedPlaces);
  
  return guaranteedPlaces;
}

function adjustForWishLevelGaming(places: NormalizedPlace[]): NormalizedPlace[] {
  const userStats = calculateUserWishStats(places);
  
  return places.map(place => {
    const userStat = userStats[place.user_id];
    
    // 全て同じ希望度や極端な分布のユーザーを検出
    if (userStat.isGaming) {
      place.normalized_weight *= 0.7; // ペナルティ適用
    }
    
    return place;
  });
}

function calculateUserWishStats(places: NormalizedPlace[]) {
  const userGroups = groupBy(places, 'user_id');
  
  return Object.entries(userGroups).reduce((acc, [userId, userPlaces]) => {
    const wishes = userPlaces.map(p => p.wish_level);
    const uniqueWishes = new Set(wishes);
    const avgWish = wishes.reduce((sum, w) => sum + w, 0) / wishes.length;
    const variance = wishes.reduce((sum, w) => sum + Math.pow(w - avgWish, 2), 0) / wishes.length;
    
    // ゲーミング判定ロジック
    const isGaming = uniqueWishes.size === 1 || // 全て同じ希望度
                     variance < 0.5 || // 分散が小さすぎる
                     (avgWish > 4.5 && userPlaces.length > 5); // 高希望度が多すぎる
    
    acc[userId] = {
      avgWish,
      variance,
      uniqueWishes: uniqueWishes.size,
      isGaming
    };
    
    return acc;
  }, {} as Record<string, any>);
}
```

### 3.3 クラスタリングアルゴリズム

#### 3.3.1 地理的クラスタリング
```typescript
function clusterPlacesByDay(places: NormalizedPlace[], trip: Trip): Map<string, NormalizedPlace[]> {
  const tripDays = generateTripDays(trip.start_date, trip.end_date);
  const dailyClusters = new Map<string, NormalizedPlace[]>();
  
  // 訪問希望日が指定されている場所を先に割り当て
  const scheduledPlaces = places.filter(p => p.visit_date);
  const unscheduledPlaces = places.filter(p => !p.visit_date);
  
  // 希望日指定場所の配置
  scheduledPlaces.forEach(place => {
    const dayKey = formatDate(place.visit_date);
    if (tripDays.includes(dayKey)) {
      if (!dailyClusters.has(dayKey)) {
        dailyClusters.set(dayKey, []);
      }
      dailyClusters.get(dayKey)!.push(place);
    }
  });
  
  // 未指定場所を地理的距離と日程バランスで配置
  const remainingDays = tripDays.filter(day => 
    (dailyClusters.get(day) || []).length < MAX_PLACES_PER_DAY
  );
  
  unscheduledPlaces.forEach(place => {
    const bestDay = findBestDayForPlace(place, dailyClusters, remainingDays);
    if (!dailyClusters.has(bestDay)) {
      dailyClusters.set(bestDay, []);
    }
    dailyClusters.get(bestDay)!.push(place);
  });
  
  return dailyClusters;
}

function findBestDayForPlace(
  place: NormalizedPlace, 
  existingClusters: Map<string, NormalizedPlace[]>,
  availableDays: string[]
): string {
  let bestDay = availableDays[0];
  let bestScore = -Infinity;
  
  for (const day of availableDays) {
    const dayPlaces = existingClusters.get(day) || [];
    
    // 地理的近接性スコア
    const proximityScore = dayPlaces.length === 0 ? 0.5 : 
      calculateAverageDistance(place, dayPlaces);
    
    // 日程バランススコア
    const balanceScore = 1 - (dayPlaces.length / MAX_PLACES_PER_DAY);
    
    // 統合スコア
    const totalScore = proximityScore * 0.6 + balanceScore * 0.4;
    
    if (totalScore > bestScore) {
      bestScore = totalScore;
      bestDay = day;
    }
  }
  
  return bestDay;
}
```

### 3.4 統合スコア最適化

#### 3.4.1 スコア計算
```typescript
interface OptimizationScore {
  overall: number;
  fairness: number;
  efficiency: number;
  details: {
    userAdoptionBalance: number;
    wishSatisfactionBalance: number;
    travelEfficiency: number;
    timeConstraintCompliance: number;
  };
}

const SCORE_WEIGHTS = {
  fairness: 0.6,    // 公平性重視
  efficiency: 0.4   // 効率性重視
};

function calculateIntegratedScore(route: NormalizedPlace[]): OptimizationScore {
  const fairnessScore = calculateFairnessScore(route);
  const efficiencyScore = calculateEfficiencyScore(route);
  
  const overall = SCORE_WEIGHTS.fairness * fairnessScore.total + 
                  SCORE_WEIGHTS.efficiency * efficiencyScore.total;
  
  return {
    overall,
    fairness: fairnessScore.total,
    efficiency: efficiencyScore.total,
    details: {
      userAdoptionBalance: fairnessScore.userAdoption,
      wishSatisfactionBalance: fairnessScore.wishSatisfaction,
      travelEfficiency: efficiencyScore.travelEfficiency,
      timeConstraintCompliance: efficiencyScore.timeCompliance
    }
  };
}
```

#### 3.4.2 公平性スコア計算
```typescript
function calculateFairnessScore(route: NormalizedPlace[]) {
  // 1. ユーザー採用バランス
  const userAdoptionBalance = calculateUserAdoptionBalance(route);
  
  // 2. 希望満足度バランス
  const wishSatisfactionBalance = calculateWishSatisfactionBalance(route);
  
  // 3. 参加度正規化
  const participationScore = calculateParticipationScore(route);
  
  // 4. 地理的公平性
  const geographicFairness = calculateGeographicFairness(route);
  
  // 5. カテゴリ多様性
  const categoryDiversity = calculateCategoryDiversityFairness(route);
  
  const total = (
    userAdoptionBalance * 0.3 +
    wishSatisfactionBalance * 0.3 +
    participationScore * 0.2 +
    geographicFairness * 0.1 +
    categoryDiversity * 0.1
  );
  
  return {
    total,
    userAdoption: userAdoptionBalance,
    wishSatisfaction: wishSatisfactionBalance,
    participation: participationScore,
    geographic: geographicFairness,
    categoryDiversity
  };
}

function calculateUserAdoptionBalance(route: NormalizedPlace[]): number {
  const userAdoptionRates = calculateUserAdoptionRates(route);
  const rates = Object.values(userAdoptionRates);
  
  if (rates.length <= 1) return 1.0;
  
  const mean = rates.reduce((sum, rate) => sum + rate, 0) / rates.length;
  const variance = rates.reduce((sum, rate) => sum + Math.pow(rate - mean, 2), 0) / rates.length;
  
  // 分散が小さいほど高スコア（公平）
  return Math.exp(-variance * 10);
}

function calculateUserAdoptionRates(route: NormalizedPlace[]): Record<string, number> {
  const userPlaceCounts = route.reduce((acc, place) => {
    acc.total = (acc.total || 0) + 1;
    acc[place.user_id] = (acc[place.user_id] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  const totalPlaces = userPlaceCounts.total;
  delete userPlaceCounts.total;
  
  return Object.entries(userPlaceCounts).reduce((acc, [userId, count]) => {
    acc[userId] = count / totalPlaces;
    return acc;
  }, {} as Record<string, number>);
}
```

#### 3.4.3 効率性スコア計算
```typescript
function calculateEfficiencyScore(route: NormalizedPlace[]) {
  // 1. 移動効率性
  const travelEfficiency = calculateTravelEfficiency(route);
  
  // 2. 時間制約遵守
  const timeConstraintCompliance = calculateTimeConstraintCompliance(route);
  
  // 3. リソース利用効率
  const resourceUtilization = calculateResourceUtilization(route);
  
  const total = (
    travelEfficiency * 0.5 +
    timeConstraintCompliance * 0.3 +
    resourceUtilization * 0.2
  );
  
  return {
    total,
    travelEfficiency,
    timeCompliance: timeConstraintCompliance,
    resourceUtilization
  };
}

function calculateTravelEfficiency(route: NormalizedPlace[]): number {
  if (route.length <= 1) return 1.0;
  
  const actualDistance = calculateTotalTravelDistance(route);
  const idealDistance = calculateIdealTravelDistance(route);
  
  // 理想距離に近いほど高スコア
  return Math.max(0, 1 - (actualDistance - idealDistance) / idealDistance);
}
```

### 3.5 移動時間・交通手段計算

#### 3.5.1 交通手段選択
```typescript
type TransportMode = 'walking' | 'public_transport' | 'car';

interface TravelTimeSettings {
  useGoogleMapsAPI: boolean;
  bufferPercentage: number;
  preferredMode?: TransportMode;
}

const TRANSPORT_SPEED = {
  walking: 4.5,          // km/h
  public_transport: 25,  // km/h (待ち時間込み)
  car: 35               // km/h (市内交通、信号込み)
};

const DISTANCE_THRESHOLDS = {
  walking_max: 0.8,      // km
  public_transport_max: 15, // km
  car_min: 15           // km超過で車推奨
};

function selectTransportationMode(origin: Location, destination: Location): TransportMode {
  const distance = calculateHaversineDistance(origin, destination);
  
  if (distance <= DISTANCE_THRESHOLDS.walking_max) {
    return 'walking';
  } else if (distance <= DISTANCE_THRESHOLDS.public_transport_max) {
    return 'public_transport';
  } else {
    return 'car';
  }
}
```

#### 3.5.2 移動時間計算
```typescript
interface TravelTimeResult {
  baseTime: number;
  bufferedTime: number;
  transportMode: TransportMode;
  estimatedCost: number;
  confidence: number;
}

function calculateTravelTime(
  origin: Location,
  destination: Location,
  transportMode?: TransportMode
): number {
  const distance = calculateHaversineDistance(origin, destination);
  const mode = transportMode || selectTransportationMode(origin, destination);
  const baseSpeed = TRANSPORT_SPEED[mode];
  
  // 基本移動時間（分）
  let travelTimeMinutes = (distance / baseSpeed) * 60;
  
  // 交通手段別の調整
  switch (mode) {
    case 'walking':
      // 実際の歩行は直線距離の1.3倍
      travelTimeMinutes *= 1.3;
      break;
      
    case 'public_transport':
      // 待ち時間と乗り換え時間を追加
      const waitTime = 8; // 平均待ち時間
      const transferTime = distance > 5 ? 10 : 0; // 乗り換え時間
      travelTimeMinutes += waitTime + transferTime;
      break;
      
    case 'car':
      // 道路係数と信号待ち
      travelTimeMinutes *= 1.4; // 道路は直線の1.4倍
      travelTimeMinutes += 5; // 信号・駐車場探し
      break;
  }
  
  // 最小移動時間の保証
  const minimumTime = getMinimumTravelTime(mode);
  return Math.max(travelTimeMinutes, minimumTime);
}

// Google Maps API使用版（プレミアム機能）
async function calculateTravelTimeWithAPI(
  origin: Location,
  destination: Location,
  transportMode: TransportMode,
  departureTime: Date
): Promise<number> {
  try {
    const googleMode = convertToGoogleMode(transportMode);
    
    const response = await fetch(`https://maps.googleapis.com/maps/api/directions/json`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        origin: `${origin.latitude},${origin.longitude}`,
        destination: `${destination.latitude},${destination.longitude}`,
        mode: googleMode,
        departure_time: Math.floor(departureTime.getTime() / 1000),
        key: Deno.env.get('GOOGLE_MAPS_API_KEY')
      })
    });
    
    const data = await response.json();
    
    if (data.status === 'OK' && data.routes.length > 0) {
      return data.routes[0].legs[0].duration.value / 60; // 秒を分に変換
    }
    
    // API失敗時のフォールバック
    return calculateTravelTime(origin, destination, transportMode);
    
  } catch (error) {
    console.warn('Google Maps API failed, using fallback calculation', error);
    return calculateTravelTime(origin, destination, transportMode);
  }
}
```

### 3.6 詳細スケジューリング

#### 3.6.1 時間割当て
```typescript
interface DailySchedule {
  date: Date;
  scheduled_places: ScheduledPlace[];
  meal_breaks: MealBreak[];
  total_travel_time: number;
  total_visit_time: number;
}

interface ScheduledPlace {
  place: NormalizedPlace;
  arrival_time: Date;
  departure_time: Date;
  travel_time_from_previous: number;
  transport_mode: TransportMode;
}

function createDetailedSchedule(
  optimizedRoutes: Map<string, NormalizedPlace[]>,
  trip: Trip
): DailySchedule[] {
  const schedules: DailySchedule[] = [];
  
  for (const [dateStr, dayPlaces] of optimizedRoutes) {
    const date = new Date(dateStr);
    const startTime = new Date(date);
    startTime.setHours(9, 0, 0, 0); // 9:00開始
    
    const dailySchedule = scheduleSingleDay(dayPlaces, startTime);
    schedules.push(dailySchedule);
  }
  
  return schedules.sort((a, b) => a.date.getTime() - b.date.getTime());
}

function scheduleSingleDay(places: NormalizedPlace[], startTime: Date): DailySchedule {
  const scheduledPlaces: ScheduledPlace[] = [];
  const mealBreaks: MealBreak[] = [];
  let currentTime = new Date(startTime);
  let lastLocation = DEFAULT_START_LOCATION;
  let totalTravelTime = 0;
  let totalVisitTime = 0;
  
  for (const place of places) {
    // 移動時間計算
    const travelTimeMinutes = calculateTravelTime(lastLocation, place.location);
    const transportMode = selectTransportationMode(lastLocation, place.location);
    
    currentTime = new Date(currentTime.getTime() + travelTimeMinutes * 60000);
    totalTravelTime += travelTimeMinutes;
    
    // 営業時間チェックと調整
    currentTime = adjustForOpeningHours(place, currentTime);
    
    // 食事時間の自動挿入
    const mealBreak = checkAndInsertMealBreak(currentTime, mealBreaks);
    if (mealBreak) {
      mealBreaks.push(mealBreak);
      currentTime = new Date(mealBreak.end_time);
    }
    
    // 場所のスケジューリング
    const arrivalTime = new Date(currentTime);
    const departureTime = new Date(currentTime.getTime() + place.stay_duration_minutes * 60000);
    totalVisitTime += place.stay_duration_minutes;
    
    scheduledPlaces.push({
      place,
      arrival_time: arrivalTime,
      departure_time: departureTime,
      travel_time_from_previous: travelTimeMinutes,
      transport_mode: transportMode
    });
    
    currentTime = departureTime;
    lastLocation = place.location;
  }
  
  return {
    date: startTime,
    scheduled_places: scheduledPlaces,
    meal_breaks: mealBreaks,
    total_travel_time: totalTravelTime,
    total_visit_time: totalVisitTime
  };
}
```

#### 3.6.2 営業時間調整
```typescript
interface OpeningHours {
  [key: number]: { // 0=日曜日, 1=月曜日, ...
    is_closed: boolean;
    open_time: string;  // "09:00"
    close_time: string; // "18:00"
  };
}

function adjustForOpeningHours(place: NormalizedPlace, proposedTime: Date): Date {
  const dayOfWeek = proposedTime.getDay();
  const openingHours = place.opening_hours?.[dayOfWeek];
  
  if (!openingHours || openingHours.is_closed) {
    // 営業していない場合は次の営業日に移動（エラーハンドリング）
    throw new Error(`Place ${place.name} is closed on ${getDayName(dayOfWeek)}`);
  }
  
  const openTime = parseTimeToHours(openingHours.open_time);
  const closeTime = parseTimeToHours(openingHours.close_time);
  const proposedHour = proposedTime.getHours() + proposedTime.getMinutes() / 60;
  
  if (proposedHour < openTime) {
    // 開店前の場合、開店時間に調整
    const adjustedTime = new Date(proposedTime);
    const hours = Math.floor(openTime);
    const minutes = (openTime % 1) * 60;
    adjustedTime.setHours(hours, minutes, 0, 0);
    return adjustedTime;
  }
  
  if (proposedHour + place.stay_duration_minutes / 60 > closeTime) {
    // 閉店時間を超える場合は除外
    throw new Error(`Place ${place.name} visit would exceed closing time`);
  }
  
  return proposedTime;
}

function parseTimeToHours(timeString: string): number {
  const [hours, minutes] = timeString.split(':').map(Number);
  return hours + minutes / 60;
}
```

#### 3.6.3 食事時間自動挿入
```typescript
interface MealBreak {
  type: 'breakfast' | 'lunch' | 'dinner';
  start_time: Date;
  end_time: Date;
  suggested_location?: Location;
  estimated_cost?: number;
}

const MEAL_WINDOWS = {
  breakfast: { start: 7, end: 9, duration: 45 },
  lunch: { start: 12, end: 14, duration: 60 },
  dinner: { start: 18, end: 20, duration: 90 }
};

function checkAndInsertMealBreak(
  currentTime: Date, 
  existingMeals: MealBreak[]
): MealBreak | null {
  const hour = currentTime.getHours() + currentTime.getMinutes() / 60;
  
  for (const [mealType, window] of Object.entries(MEAL_WINDOWS)) {
    if (hour >= window.start && hour <= window.end) {
      // この時間帯の食事がまだ挿入されていない場合
      const existingMeal = existingMeals.find(meal => meal.type === mealType);
      if (!existingMeal) {
        const startTime = new Date(currentTime);
        const endTime = new Date(currentTime.getTime() + window.duration * 60000);
        
        return {
          type: mealType as 'breakfast' | 'lunch' | 'dinner',
          start_time: startTime,
          end_time: endTime,
          suggested_location: findNearbyRestaurant(currentTime), // 実装は簡略化
          estimated_cost: estimateMealCost(mealType)
        };
      }
    }
  }
  
  return null;
}

function findNearbyRestaurant(location: Location): Location {
  // 実装簡略化: 現在地周辺のレストラン提案
  return {
    latitude: location.latitude + (Math.random() - 0.5) * 0.01,
    longitude: location.longitude + (Math.random() - 0.5) * 0.01,
    name: "Nearby Restaurant"
  };
}

function estimateMealCost(mealType: string): number {
  const costs = {
    breakfast: 800,
    lunch: 1200,
    dinner: 2000
  };
  return costs[mealType] || 1000;
}
```

## 4. Stripe決済連携

### 4.1 Checkout Session作成

#### 4.1.1 Edge Function実装
```typescript
// supabase/functions/create-checkout-session/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import Stripe from 'https://esm.sh/stripe@12.0.0?target=deno';

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') || '', {
  apiVersion: '2022-11-15',
});

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const { priceId, userId, successUrl, cancelUrl } = await req.json();

    // ユーザー検証
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();

    if (error || !user) {
      throw new Error('User not found');
    }

    // Stripe Customer作成または取得
    let customerId = user.stripe_customer_id;
    
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: {
          supabase_user_id: userId,
        },
      });
      
      customerId = customer.id;
      
      // Supabaseユーザー情報更新
      await supabase
        .from('users')
        .update({ stripe_customer_id: customerId })
        .eq('id', userId);
    }

    // Checkout Session作成
    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        user_id: userId,
      },
    });

    return new Response(
      JSON.stringify({
        sessionId: session.id,
        url: session.url,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error creating checkout session:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});
```

### 4.2 Webhook処理

#### 4.2.1 Stripe Webhook Edge Function
```typescript
// supabase/functions/stripe-webhook/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import Stripe from 'https://esm.sh/stripe@12.0.0?target=deno';

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') || '', {
  apiVersion: '2022-11-15',
});

const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET')!;

serve(async (req) => {
  const signature = req.headers.get('Stripe-Signature')!;
  const body = await req.text();

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return new Response('Webhook signature verification failed', { status: 400 });
  }

  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session, supabase);
        break;
      
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription, supabase);
        break;
      
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription, supabase);
        break;
      
      case 'invoice.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.Invoice, supabase);
        break;
        
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return new Response('OK', { status: 200 });
  } catch (error) {
    console.error('Error processing webhook:', error);
    return new Response('Error processing webhook', { status: 500 });
  }
});

async function handleCheckoutCompleted(
  session: Stripe.Checkout.Session,
  supabase: SupabaseClient
) {
  const customerId = session.customer as string;
  const subscriptionId = session.subscription as string;
  
  // ユーザー情報取得
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('*')
    .eq('stripe_customer_id', customerId)
    .single();

  if (userError || !user) {
    throw new Error(`User not found for customer ${customerId}`);
  }

  // サブスクリプション情報取得
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);
  
  // プレミアムステータス更新
  const { error: updateError } = await supabase
    .from('users')
    .update({
      is_premium: true,
      premium_expires_at: new Date(subscription.current_period_end * 1000).toISOString(),
      stripe_subscription_id: subscriptionId,
      updated_at: new Date().toISOString(),
    })
    .eq('id', user.id);

  if (updateError) {
    throw new Error(`Failed to update user premium status: ${updateError.message}`);
  }

  console.log(`User ${user.id} upgraded to premium`);
}

async function handleSubscriptionUpdated(
  subscription: Stripe.Subscription,
  supabase: SupabaseClient
) {
  const customerId = subscription.customer as string;
  
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('*')
    .eq('stripe_customer_id', customerId)
    .single();

  if (userError || !user) {
    throw new Error(`User not found for customer ${customerId}`);
  }

  const isActive = subscription.status === 'active';
  const expiresAt = new Date(subscription.current_period_end * 1000).toISOString();

  const { error: updateError } = await supabase
    .from('users')
    .update({
      is_premium: isActive,
      premium_expires_at: isActive ? expiresAt : null,
      updated_at: new Date().toISOString(),
    })
    .eq('id', user.id);

  if (updateError) {
    throw new Error(`Failed to update subscription status: ${updateError.message}`);
  }

  console.log(`User ${user.id} subscription updated: ${subscription.status}`);
}
```

## 5. リアルタイム同期

### 5.1 Supabase Realtime設定

#### 5.1.1 テーブル設定
```sql
-- トリップテーブルでリアルタイム有効化
ALTER PUBLICATION supabase_realtime ADD TABLE trips;
ALTER PUBLICATION supabase_realtime ADD TABLE places;
ALTER PUBLICATION supabase_realtime ADD TABLE messages;
ALTER PUBLICATION supabase_realtime ADD TABLE trip_members;

-- 最適化結果テーブル（新規）
CREATE TABLE optimization_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  trip_id UUID NOT NULL REFERENCES trips(id) ON DELETE CASCADE,
  optimized_route JSONB NOT NULL,
  optimization_score JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id)
);

ALTER PUBLICATION supabase_realtime ADD TABLE optimization_results;
```

#### 5.1.2 フロントエンド購読設定
```typescript
// hooks/useRealtimeSync.ts
import { useEffect } from 'react';
import { useSupabase } from './useSupabase';
import { useStore } from '../store/useStore';

export const useRealtimeSync = (tripId: string | null) => {
  const supabase = useSupabase();
  const { updateTrip, updatePlace, addMessage, updateOptimizationResult } = useStore();

  useEffect(() => {
    if (!tripId || !supabase) return;

    // Places購読
    const placesSubscription = supabase
      .channel(`places:trip_id=eq.${tripId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'places',
          filter: `trip_id=eq.${tripId}`,
        },
        (payload) => {
          console.log('Places change received:', payload);
          
          switch (payload.eventType) {
            case 'INSERT':
            case 'UPDATE':
              updatePlace(payload.new);
              break;
            case 'DELETE':
              // Place削除処理
              break;
          }
        }
      )
      .subscribe();

    // Messages購読
    const messagesSubscription = supabase
      .channel(`messages:trip_id=eq.${tripId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `trip_id=eq.${tripId}`,
        },
        (payload) => {
          console.log('New message received:', payload);
          addMessage(payload.new);
        }
      )
      .subscribe();

    // 最適化結果購読
    const optimizationSubscription = supabase
      .channel(`optimization:trip_id=eq.${tripId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'optimization_results',
          filter: `trip_id=eq.${tripId}`,
        },
        (payload) => {
          console.log('Optimization result received:', payload);
          updateOptimizationResult(payload.new);
        }
      )
      .subscribe();

    return () => {
      placesSubscription.unsubscribe();
      messagesSubscription.unsubscribe();
      optimizationSubscription.unsubscribe();
    };
  }, [tripId, supabase]);
};
```

### 5.2 最適化結果の同期

#### 5.2.1 結果保存と配信
```typescript
// 最適化結果の保存とリアルタイム配信
async function saveAndBroadcastResults(
  tripId: string,
  optimizedRoute: OptimizedRoute,
  supabase: SupabaseClient
) {
  // 結果をデータベースに保存
  const { data, error } = await supabase
    .from('optimization_results')
    .insert({
      trip_id: tripId,
      optimized_route: optimizedRoute.daily_schedules,
      optimization_score: optimizedRoute.optimization_score,
      created_by: optimizedRoute.created_by
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to save optimization result: ${error.message}`);
  }

  // Places テーブルのスケジュール情報更新
  for (const dailySchedule of optimizedRoute.daily_schedules) {
    for (const scheduledPlace of dailySchedule.scheduled_places) {
      await supabase
        .from('places')
        .update({
          scheduled: true,
          scheduled_date: dailySchedule.date,
          arrival_time: scheduledPlace.arrival_time,
          departure_time: scheduledPlace.departure_time,
          transport_mode: scheduledPlace.transport_mode,
          updated_at: new Date().toISOString()
        })
        .eq('id', scheduledPlace.place.id);
    }
  }

  console.log(`Optimization result saved and broadcasted for trip ${tripId}`);
  return data;
}
```

## 6. エラーハンドリング・ロギング

### 6.1 共通エラーハンドリング

#### 6.1.1 エラータイプ定義
```typescript
export class VoypathError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly details?: any;

  constructor(
    message: string,
    code: string = 'UNKNOWN_ERROR',
    statusCode: number = 500,
    details?: any
  ) {
    super(message);
    this.name = 'VoypathError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

export class OptimizationError extends VoypathError {
  constructor(message: string, details?: any) {
    super(message, 'OPTIMIZATION_ERROR', 500, details);
    this.name = 'OptimizationError';
  }
}

export class ValidationError extends VoypathError {
  constructor(message: string, details?: any) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

export class AuthorizationError extends VoypathError {
  constructor(message: string = 'Access denied') {
    super(message, 'AUTHORIZATION_ERROR', 403);
    this.name = 'AuthorizationError';
  }
}
```

#### 6.1.2 エラーハンドリング関数
```typescript
export function handleEdgeFunctionError(error: unknown): Response {
  console.error('Edge Function Error:', error);

  if (error instanceof VoypathError) {
    return new Response(
      JSON.stringify({
        error: {
          code: error.code,
          message: error.message,
          details: error.details,
        },
      }),
      {
        status: error.statusCode,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }

  // 未知のエラー
  return new Response(
    JSON.stringify({
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'An unexpected error occurred',
      },
    }),
    {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    }
  );
}
```

### 6.2 ロギング戦略

#### 6.2.1 構造化ログ
```typescript
interface LogEntry {
  timestamp: string;
  level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  context?: Record<string, any>;
  userId?: string;
  tripId?: string;
  functionName?: string;
  executionTime?: number;
}

export function log(
  level: LogEntry['level'],
  message: string,
  context?: Record<string, any>
) {
  const logEntry: LogEntry = {
    timestamp: new Date().toISOString(),
    level,
    message,
    context,
    functionName: Deno.env.get('SUPABASE_FUNCTION_NAME'),
  };

  console.log(JSON.stringify(logEntry));
}

export function logOptimization(
  tripId: string,
  userId: string,
  executionTime: number,
  placesCount: number,
  optimizationScore: OptimizationScore
) {
  log('info', 'Route optimization completed', {
    tripId,
    userId,
    executionTime,
    placesCount,
    optimizationScore: optimizationScore.overall,
    fairnessScore: optimizationScore.fairness,
    efficiencyScore: optimizationScore.efficiency,
  });
}
```

## 7. パフォーマンス最適化

### 7.1 計算量削減

#### 7.1.1 大量データの事前フィルタリング
```typescript
const MAX_PLACES_FOR_FULL_OPTIMIZATION = 25;
const MAX_PLACES_PER_DAY = 8;

function preprocessLargePlaceSets(places: NormalizedPlace[]): NormalizedPlace[] {
  if (places.length <= MAX_PLACES_FOR_FULL_OPTIMIZATION) {
    return places;
  }

  console.log(`Large place set detected (${places.length} places), applying preprocessing`);

  // 1. 重み上位候補の選出
  const topWeightedPlaces = selectTopWeightedPlaces(places, 0.8);
  
  // 2. 地理的分散の確保
  const geographicallyDiversePlaces = ensureGeographicalDiversity(topWeightedPlaces);
  
  // 3. ユーザー公平性の確保
  const fairlyDistributedPlaces = ensureUserFairness(geographicallyDiversePlaces, places);
  
  return fairlyDistributedPlaces.slice(0, MAX_PLACES_FOR_FULL_OPTIMIZATION);
}

function selectTopWeightedPlaces(places: NormalizedPlace[], percentage: number): NormalizedPlace[] {
  const sortedByWeight = [...places].sort((a, b) => b.normalized_weight - a.normalized_weight);
  const cutoff = Math.floor(places.length * percentage);
  return sortedByWeight.slice(0, cutoff);
}

function ensureGeographicalDiversity(places: NormalizedPlace[]): NormalizedPlace[] {
  const clusters = performKMeansClustering(places, Math.min(5, Math.ceil(places.length / 5)));
  
  // 各クラスターから代表的な場所を選出
  const representatives: NormalizedPlace[] = [];
  
  for (const cluster of clusters) {
    // クラスター内で重みが最も高い場所を選出
    const bestInCluster = cluster.reduce((best, current) => 
      current.normalized_weight > best.normalized_weight ? current : best
    );
    representatives.push(bestInCluster);
    
    // クラスターサイズに応じて追加場所を選出
    const additionalCount = Math.floor(cluster.length / 3);
    const sorted = cluster
      .filter(p => p !== bestInCluster)
      .sort((a, b) => b.normalized_weight - a.normalized_weight);
    representatives.push(...sorted.slice(0, additionalCount));
  }
  
  return representatives;
}
```

### 7.2 キャッシュ戦略

#### 7.2.1 結果キャッシュ
```typescript
interface OptimizationCache {
  tripId: string;
  placesHash: string;
  result: OptimizedRoute;
  createdAt: Date;
  expiresAt: Date;
}

const CACHE_DURATION_MINUTES = 30;

async function getCachedOptimization(
  tripId: string,
  places: NormalizedPlace[],
  supabase: SupabaseClient
): Promise<OptimizedRoute | null> {
  const placesHash = generatePlacesHash(places);
  
  const { data, error } = await supabase
    .from('optimization_cache')
    .select('*')
    .eq('trip_id', tripId)
    .eq('places_hash', placesHash)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false })
    .limit(1)
    .single();

  if (error || !data) {
    return null;
  }

  log('info', 'Using cached optimization result', { tripId, placesHash });
  return data.result as OptimizedRoute;
}

async function setCachedOptimization(
  tripId: string,
  places: NormalizedPlace[],
  result: OptimizedRoute,
  supabase: SupabaseClient
): Promise<void> {
  const placesHash = generatePlacesHash(places);
  const expiresAt = new Date();
  expiresAt.setMinutes(expiresAt.getMinutes() + CACHE_DURATION_MINUTES);

  await supabase
    .from('optimization_cache')
    .upsert({
      trip_id: tripId,
      places_hash: placesHash,
      result,
      expires_at: expiresAt.toISOString(),
    });
}

function generatePlacesHash(places: NormalizedPlace[]): string {
  const hashInput = places
    .sort((a, b) => a.id.localeCompare(b.id))
    .map(p => `${p.id}:${p.wish_level}:${p.stay_duration_minutes}:${p.visit_date || ''}`)
    .join('|');
  
  return btoa(hashInput).slice(0, 32); // 簡易ハッシュ
}
```

### 7.3 並列処理最適化

#### 7.3.1 非同期処理の並列化
```typescript
async function optimizeMultipleDays(
  clusteredPlaces: Map<string, NormalizedPlace[]>
): Promise<Map<string, NormalizedPlace[]>> {
  const optimizationPromises = Array.from(clusteredPlaces.entries()).map(
    async ([date, places]) => {
      const optimizedPlaces = await optimizeSingleDayAsync(places);
      return [date, optimizedPlaces] as [string, NormalizedPlace[]];
    }
  );

  const results = await Promise.all(optimizationPromises);
  return new Map(results);
}

async function optimizeSingleDayAsync(places: NormalizedPlace[]): Promise<NormalizedPlace[]> {
  return new Promise((resolve) => {
    // 非同期でアルゴリズムを実行
    setTimeout(() => {
      const result = optimizeSingleDay(places);
      resolve(result);
    }, 0);
  });
}
```

## 8. セキュリティ実装

### 8.1 認証・認可

#### 8.1.1 Edge Function認証チェック
```typescript
async function validateUserAccess(
  tripId: string,
  userId: string,
  supabase: SupabaseClient,
  requiredRole?: 'admin' | 'member'
): Promise<void> {
  // ユーザーが旅行のメンバーかチェック
  const { data: membership, error } = await supabase
    .from('trip_members')
    .select('role')
    .eq('trip_id', tripId)
    .eq('user_id', userId)
    .single();

  if (error || !membership) {
    throw new AuthorizationError('You are not a member of this trip');
  }

  if (requiredRole === 'admin' && membership.role !== 'admin') {
    throw new AuthorizationError('Admin access required');
  }
}

async function validatePremiumAccess(
  userId: string,
  supabase: SupabaseClient
): Promise<void> {
  const { data: user, error } = await supabase
    .from('users')
    .select('is_premium, premium_expires_at')
    .eq('id', userId)
    .single();

  if (error || !user) {
    throw new AuthorizationError('User not found');
  }

  if (!user.is_premium) {
    throw new AuthorizationError('Premium subscription required');
  }

  if (user.premium_expires_at && new Date(user.premium_expires_at) < new Date()) {
    throw new AuthorizationError('Premium subscription expired');
  }
}
```

### 8.2 入力検証

#### 8.2.1 スキーマ検証
```typescript
interface OptimizationRequestSchema {
  tripId: string;
  userId: string;
  settings?: {
    useGoogleMapsAPI?: boolean;
    bufferPercentage?: number;
    preferredTransportMode?: TransportMode;
  };
}

function validateOptimizationRequest(data: any): OptimizationRequestSchema {
  if (!data.tripId || typeof data.tripId !== 'string') {
    throw new ValidationError('Invalid tripId');
  }

  if (!data.userId || typeof data.userId !== 'string') {
    throw new ValidationError('Invalid userId');
  }

  // UUID形式チェック
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  
  if (!uuidRegex.test(data.tripId)) {
    throw new ValidationError('Invalid tripId format');
  }

  if (!uuidRegex.test(data.userId)) {
    throw new ValidationError('Invalid userId format');
  }

  return {
    tripId: data.tripId,
    userId: data.userId,
    settings: data.settings || {}
  };
}
```

### 8.3 Rate Limiting

#### 8.3.1 最適化実行制限
```typescript
const OPTIMIZATION_RATE_LIMIT = {
  FREE_USER_PER_HOUR: 3,
  PREMIUM_USER_PER_HOUR: 20,
  WINDOW_MINUTES: 60
};

async function checkOptimizationRateLimit(
  userId: string,
  isPremium: boolean,
  supabase: SupabaseClient
): Promise<void> {
  const windowStart = new Date();
  windowStart.setMinutes(windowStart.getMinutes() - OPTIMIZATION_RATE_LIMIT.WINDOW_MINUTES);

  const { data: recentOptimizations, error } = await supabase
    .from('optimization_results')
    .select('created_at')
    .eq('created_by', userId)
    .gte('created_at', windowStart.toISOString());

  if (error) {
    throw new Error(`Failed to check rate limit: ${error.message}`);
  }

  const limit = isPremium 
    ? OPTIMIZATION_RATE_LIMIT.PREMIUM_USER_PER_HOUR 
    : OPTIMIZATION_RATE_LIMIT.FREE_USER_PER_HOUR;

  if (recentOptimizations.length >= limit) {
    throw new VoypathError(
      `Rate limit exceeded. ${isPremium ? 'Premium' : 'Free'} users can perform ${limit} optimizations per hour.`,
      'RATE_LIMIT_EXCEEDED',
      429
    );
  }
}
```

## 9. 監視・アナリティクス

### 9.1 パフォーマンス監視

#### 9.1.1 実行時間計測
```typescript
export function withPerformanceMonitoring<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  functionName: string
): T {
  return (async (...args: any[]) => {
    const startTime = Date.now();
    
    try {
      const result = await fn(...args);
      const executionTime = Date.now() - startTime;
      
      log('info', `Function ${functionName} completed`, {
        executionTime,
        status: 'success'
      });
      
      return result;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      log('error', `Function ${functionName} failed`, {
        executionTime,
        status: 'error',
        error: error.message
      });
      
      throw error;
    }
  }) as T;
}

// 使用例
export const optimizeRouteWithMonitoring = withPerformanceMonitoring(
  optimizeRoute,
  'optimizeRoute'
);
```

### 9.2 ビジネス指標収集

#### 9.2.1 使用状況追跡
```typescript
interface UsageEvent {
  user_id: string;
  event_type: 'optimization_started' | 'optimization_completed' | 'optimization_failed';
  trip_id: string;
  metadata: Record<string, any>;
  created_at: string;
}

async function trackUsageEvent(
  event: Omit<UsageEvent, 'created_at'>,
  supabase: SupabaseClient
): Promise<void> {
  await supabase
    .from('usage_events')
    .insert({
      ...event,
      created_at: new Date().toISOString()
    });
}

// 最適化完了時の追跡
async function trackOptimizationCompletion(
  tripId: string,
  userId: string,
  result: OptimizedRoute,
  executionTime: number,
  supabase: SupabaseClient
) {
  await trackUsageEvent({
    user_id: userId,
    event_type: 'optimization_completed',
    trip_id: tripId,
    metadata: {
      places_count: result.daily_schedules.reduce((sum, day) => sum + day.scheduled_places.length, 0),
      optimization_score: result.optimization_score.overall,
      execution_time: executionTime,
      days_count: result.daily_schedules.length
    }
  }, supabase);
}
```