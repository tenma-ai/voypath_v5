⏺ Add My Places からビジュアル化までの完全フロー分析

  1. システム概要とアーキテクチャ

  1.1 基本的な流れ

  Add My Places → 自動最適化 → リアルタイム更新 → ビジュアル化
       ↓              ↓              ↓              ↓
    my_places    destinations    places      map/list/calendar
      table      + user_prefs    table          views

  1.2 データベース構造

  -- ユーザーのウィッシュリスト（個人の希望）
  my_places {
    id: uuid (PK)
    user_id: uuid (nullable) -- 認証済みユーザー
    session_id: text (nullable) -- ゲストユーザー
    group_id: uuid (FK to trip_groups)
    name: text
    address: text
    place_id: text -- Google Places ID
    latitude: numeric
    longitude: numeric
    preference_score: integer (1-5)
    preferred_duration: integer (minutes)
    preferred_date: date (nullable)
    notes: text
    is_personal_favorite: boolean
    created_at: timestamptz
    updated_at: timestamptz
  }

  -- トリップの候補地（最適化対象）
  destinations {
    id: uuid (PK)
    group_id: uuid (FK to trip_groups)
    name: text
    address: text
    place_id: text
    latitude: numeric
    longitude: numeric
    created_by: uuid (nullable)
    created_at: timestamptz
  }

  -- ユーザー毎の候補地への評価
  user_preferences {
    id: uuid (PK)
    group_id: uuid (FK to trip_groups)
    user_id: uuid (nullable)
    session_id: text (nullable)
    destination_id: uuid (FK to destinations)
    preference_score: integer (1-5)
    preferred_duration: integer (minutes)
    notes: text
    is_personal_favorite: boolean
    created_at: timestamptz
  }

  -- 最適化結果（採用された場所）
  places {
    id: uuid (PK)
    group_id: uuid (FK to trip_groups)
    name: text
    address: text
    latitude: numeric
    longitude: numeric
    visit_order: integer -- 訪問順序
    scheduled_date: date (nullable)
    duration: integer (minutes)
    created_at: timestamptz
  }

  2. ファイル構造とコンポーネント

  2.1 UIコンポーネント階層

  /app/my-trip/my-places/
  ├── page.tsx              -- My Places メインページ
  └── add/page.tsx          -- 場所追加フォーム

  /app/my-trip/
  └── page.tsx              -- Trip メインページ（ビジュアル化）

  /components/places/
  ├── google-places-search.tsx    -- Google Places検索
  ├── map-view.tsx               -- マップビュー
  ├── calendar-view.tsx          -- カレンダービュー
  └── interactive-list-view.tsx  -- リストビュー

  2.2 バックエンドアクション

  /lib/actions/
  ├── my-places-actions.ts      -- My Places CRUD + 自動最適化
  ├── optimization-actions.ts   -- 最適化アルゴリズム
  └── place-actions.ts         -- Places CRUD

  /lib/optimization/
  ├── complete-optimizer-v2.ts  -- メイン最適化エンジン
  ├── data-preprocessor.ts      -- データ前処理
  └── route-optimizer.ts        -- ルート最適化

  3. 詳細データフロー

  3.1 Phase 1: Add My Places（ウィッシュリスト追加）

  入力フロー

  // /app/my-trip/my-places/add/page.tsx
  const handleSubmit = async () => {
    const placeData: MyPlaceData = {
      user_id: userId,
      session_id: sessionId,
      group_id: tripId,
      name: placeName,
      address: placeAddress,
      place_id: googlePlaceId,
      latitude: coordinates.lat,
      longitude: coordinates.lng,
      preference_score: rating,        // 1-5
      preferred_duration: duration,    // minutes
      preferred_date: selectedDate,
      notes: userNotes,
      is_personal_favorite: isFavorite
    }

    await addPlaceToMyPlaces(placeData)
  }

  データベース処理

  // /lib/actions/my-places-actions.ts: addPlaceToMyPlaces()

  // 1. my_placesテーブルに挿入
  const { data: myPlaceData, error } = await supabase
    .from('my_places')
    .insert(insertData)
    .select()
    .single();

  // 2. 🎯 自動統合: destinationsテーブルに追加
  const { data: newDestination } = await supabase
    .from('destinations')
    .insert({
      group_id: insertData.group_id,
      name: insertData.name,
      address: insertData.address,
      place_id: insertData.place_id,
      latitude: insertData.latitude,
      longitude: insertData.longitude,
      created_by: userId,
    })

  // 3. 🎯 自動統合: user_preferencesテーブルに追加
  const { error: preferenceError } = await supabase
    .from('user_preferences')
    .insert({
      group_id: insertData.group_id,
      user_id: userId,
      session_id: insertData.session_id,
      destination_id: destinationId,
      preference_score: insertData.preference_score,
      preferred_duration: insertData.preferred_duration,
      notes: insertData.notes,
      is_personal_favorite: insertData.is_personal_favorite,
    });

  // 4. 🎯 自動最適化トリガー
  await triggerAutomaticOptimization(insertData.group_id, insertData.session_id);

  3.2 Phase 2: 自動最適化プロセス

  最適化トリガー

  // /lib/actions/my-places-actions.ts: triggerAutomaticOptimization()

  async function triggerAutomaticOptimization(groupId: string, sessionId: string) {
    // destinations数をチェック
    const { data: destinations } = await supabase
      .from('destinations')
      .select('id')
      .eq('group_id', groupId);

    // 1箇所以上あれば最適化実行
    if (destinations && destinations.length >= 1) {
      const userContext = {
        id: null,
        sessionId: sessionId,
        isGuest: true
      };

      // メイン最適化関数を呼び出し
      const result = await optimizeTripRoute(groupId, userContext);

      if (result.status === 'success') {
        // リアルタイム更新通知
        await broadcastOptimizationUpdate(groupId, result.data);
      }
    }
  }

  最適化アルゴリズム詳細

  // /lib/actions/optimization-actions.ts: optimizeTripRoute()

  export async function optimizeTripRoute(groupId, currentUser, options) {
    const tracker = new PerformanceTracker()

    // Step 1: データ前処理
    const preprocessedData = await dataPreprocessor.preprocessOptimizationData(groupId)

    // Step 2: エッジケース処理（単一場所）
    if (preprocessedData.destinationLocations?.length === 1) {
      return await handleSingleDestinationCase(groupId, preprocessedData, tracker);
    }

    // Step 3: 複数場所の最適化実行
    const optimizer = new CompleteOptimizerV2()
    const optimizationResult = await optimizer.optimize(processedData.input, options)

    // Step 4: 結果をデータベースに保存
    const routeManager = IntegratedRouteManager.create(groupId, currentUser.id, currentUser.sessionId)
    const storageResult = await routeManager.saveOptimizationResult(optimizationResult)

    return {
      status: 'success',
      data: storageResult.route?.route_data
    }
  }

  単一場所エッジケース処理

  // /lib/actions/optimization-actions.ts: handleSingleDestinationCase()

  async function handleSingleDestinationCase(groupId, preprocessedData, tracker) {
    // 単一destination情報を取得
    const { data: destinations } = await supabase
      .from('destinations')
      .select('*')
      .eq('group_id', groupId)
      .limit(1);

    const destination = destinations[0];

    // user_preferencesから希望時間を取得
    const { data: preferences } = await supabase
      .from('user_preferences')
      .select('*')
      .eq('group_id', groupId)
      .eq('destination_id', destination.id);

    const preferredDuration = preferences?.length > 0
      ? preferences[0].preferred_duration
      : 60; // デフォルト1時間

    // 既存のplacesレコードを削除（新しい最適化で置き換え）
    await supabase.from('places').delete().eq('group_id', groupId);

    // 単一場所を100%採用としてplacesテーブルに保存
    const optimizedPlace = {
      group_id: groupId,
      name: destination.name,
      address: destination.address,
      latitude: destination.latitude,
      longitude: destination.longitude,
      visit_order: 1,
      scheduled_date: null,
      duration: preferredDuration,
      created_at: new Date().toISOString()
    };

    const { error: placesError } = await supabase
      .from('places')
      .insert(optimizedPlace);

    return {
      status: 'success',
      data: {
        status: 'single_destination_adopted',
        selectedDestinations: [optimizedPlace]
      }
    };
  }

  3.3 Phase 3: リアルタイム更新システム

  更新ブロードキャスト

  // /lib/actions/my-places-actions.ts: broadcastOptimizationUpdate()

  async function broadcastOptimizationUpdate(groupId: string, optimizationData: any) {
    // Supabase Realtimeでグループメンバーに通知
    const { error } = await supabase
      .from('optimization_updates')
      .insert({
        group_id: groupId,
        update_type: 'route_optimized',
        data: optimizationData,
        timestamp: new Date().toISOString()
      });
  }

  クライアント側リアルタイム受信

  // /app/my-trip/page.tsx

  useEffect(() => {
    if (!activeTrip?.id) return;

    const supabase = createClient();
    const subscription = supabase
      .channel(`optimization_updates_${activeTrip.id}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'optimization_updates',
        filter: `group_id=eq.${activeTrip.id}`
      }, (payload) => {
        if (payload.new.update_type === 'route_optimized') {
          fetchTripDetails(); // プランデータの再読み込み

          toast({
            title: "プランが更新されました",
            description: "新しい場所が追加され、ルートが最適化されました",
          });
        }
      })
      .subscribe();

    return () => subscription.unsubscribe();
  }, [activeTrip]);

  3.4 Phase 4: ビジュアル化表示

  データ取得とレンダリング

  // /app/my-trip/page.tsx: fetchTripDetails()

  const fetchTripDetails = async () => {
    // 🎯 採用済みのみ表示: placesテーブルから最適化結果のみ取得
    const { data: optimizedPlaces } = await supabase
      .from('places')
      .select('*')
      .eq('group_id', activeTrip.id)
      .order('visit_order', { ascending: true });

    setPlaces(optimizedPlaces || []);

    // メンバー情報も取得（カラーマッピング用）
    const { data: memberData } = await supabase
      .from('group_members')
      .select('*')
      .eq('group_id', activeTrip.id);

    setMembers(memberData || []);
  }

  マップビュー表示

  // /app/my-trip/page.tsx: Map TabsContent

  {/* 既存の場所ピン（メンバーカラー対応） */}
  {places.map((place, index) => {
    const memberColor = members.length > 0
      ? members[index % members.length]?.assigned_color || '#3B82F6'
      : '#3B82F6';

    return (
      <Marker
        key={place.id}
        position={{ lat: place.latitude, lng: place.longitude }}
        icon={{
          path: google.maps.SymbolPath.CIRCLE,
          scale: 12,
          fillColor: memberColor,
          fillOpacity: 1,
          strokeWeight: 2,
          strokeColor: '#FFFFFF'
        }}
        label={{ 
          text: place.visit_order?.toString() || (index + 1).toString(), 
          color: "white",
          fontSize: "12px",
          fontWeight: "bold"
        }}
      />
    );
  })}

  {/* ルートライン表示 */}
  {places.length > 1 && (
    <Polyline
      path={places
        .sort((a, b) => (a.visit_order || 0) - (b.visit_order || 0))
        .map(place => ({ lat: place.latitude, lng: place.longitude }))}
      options={{
        strokeColor: '#3B82F6',
        strokeOpacity: 0.8,
        strokeWeight: 3,
        geodesic: true,
      }}
    />
  )}

  リストビュー表示

  // /app/my-trip/page.tsx: List TabsContent

  {places.map((place, index) => (
    <div key={place.id} className="bg-white dark:bg-gray-800 rounded-lg border p-4">
      <div className="flex items-start space-x-3">
        <div className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center">
          {place.visit_order || index + 1}
        </div>
        <div className="flex-1">
          <h3 className="text-lg font-semibold">{place.name}</h3>
          <p className="text-sm text-gray-500">{place.address}</p>
          <div className="flex items-center space-x-4 mt-2 text-sm text-gray-500">
            {place.scheduled_date && (
              <span>📅 {new Date(place.scheduled_date).toLocaleDateString()}</span>
            )}
            {place.duration && (
              <span>⏰ {place.duration} min</span>
            )}
          </div>
        </div>
      </div>
    </div>
  ))}

  4. 現在の問題点と改善策

  4.1 特定済み問題

  問題1: "Failed to fetch your places" エラー

  症状: My Placesページでデータ取得失敗
  原因: getMyPlacesForTrip()関数でのセッション認証またはDB接続問題
  場所: /lib/actions/my-places-actions.ts:234-306
  改善策:
  - 詳細ログ追加済み
  - 入力値バリデーション強化
  - エラーハンドリング改善

  問題2: TypeScript型エラー

  症状: ビルド時のコンパイルエラー
  原因:
  - determineZoomLevel()パラメータ不一致
  - DestinationVisitプロパティアクセス間違い
  場所: /components/places/calendar-view.tsx
  改善策: ✅ 修正済み

  問題3: サーバー/クライアントSupabaseインポート混在

  症状: サーバーアクションでクライアント側インポート使用
  場所: /lib/services/route-storage.ts, /lib/services/real-time-sync.ts
  改善策: ✅ 修正済み

  4.2 潜在的な問題と改善提案

  改善1: エラーハンドリングの統一化

  // 統一エラーレスポンス形式
  interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
      code: string;
      message: string;
      details?: any;
    };
  }

  改善2: データ整合性の保証

  // トランザクション処理での一括更新
  const result = await supabase.rpc('add_place_with_optimization', {
    place_data: placeData,
    group_id: groupId,
    session_id: sessionId
  });

  改善3: キャッシュ機能の追加

  // React Query or SWRを使用したデータキャッシュ
  const { data: places, mutate } = useSWR(
    `places-${activeTrip.id}`,
    () => getMyPlacesForTrip(activeTrip.id, sessionId),
    { refreshInterval: 5000 }
  );

  改善4: オフライン対応

  // ServiceWorkerでのオフラインサポート
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }

  改善5: パフォーマンス最適化

  // メモ化と遅延ローディング
  const MemoizedMapView = React.memo(MapView);
  const LazyCalendarView = lazy(() => import('./calendar-view'));

  5. データフロー図

  graph TD
      A[User adds place via UI] --> B[addPlaceToMyPlaces()]
      B --> C[Insert into my_places]
      B --> D[Auto-integrate to destinations]
      B --> E[Auto-integrate to user_preferences]
      B --> F[triggerAutomaticOptimization()]
      F --> G{Single or Multiple places?}
      G -->|Single| H[handleSingleDestinationCase()]
      G -->|Multiple| I[CompleteOptimizerV2.optimize()]
      H --> J[Insert into places table]
      I --> J
      J --> K[broadcastOptimizationUpdate()]
      K --> L[Realtime notification]
      L --> M[fetchTripDetails()]
      M --> N[Update UI visualization]
      N --> O[Map/List/Calendar views]

  6. 次のステップ

  1. 緊急: "Failed to fetch your places"エラーの根本原因特定と修正
  2. 重要: エンドツーエンドテストの実装と自動化フロー検証
  3. 改善: パフォーマンス最適化とUX向上
  4. 拡張: オフライン機能とプッシュ通知の追加

  この分析により、add my placesからビジュアル化までの完全なフローが明確になりました。現在のメイン問題はMy
  Placesページのデータ取得エラーですが、追加したデバッグログにより具体的な原因を特定できるはずです。