// Enhanced day splitting with accommodation integration and meal scheduling

import type { 
  DaySchedule,
  DailyScheduleConfig,
  ScheduledDestination,
  MealBreak,
  AccommodationSuggestion,
  DaySummary,
  DayValidation,
  MultiDayItinerary
} from './daily-schedule-types'
import type { 
  DestinationVisit,
  DetailedTransportSegment,
  DetailedItinerary
} from './detailed-route-types'
import { suggestAccommodation, suggestAllAccommodations } from './accommodation-suggester'
import { insertLunchBreaks, addDinnerIfNeeded } from './meal-scheduler'
// Helper function to create day start time
function createDayStartTime(date: Date, config: EnhancedDailyConfig): Date {
  const startTime = new Date(date)
  startTime.setHours(config.startTimeHour, 0, 0, 0)
  return startTime
}

// Enhanced configuration with accommodation preferences
export interface EnhancedDailyConfig extends DailyScheduleConfig {
  accommodationQuality: 'budget' | 'standard' | 'premium'
  includeMealBreaks: boolean
  optimizeAccommodationLocation: boolean
  allowLateArrival: boolean // Allow activities past 6 PM if needed
}

// Default enhanced configuration
export const DEFAULT_ENHANCED_CONFIG: EnhancedDailyConfig = {
  startTimeHour: 9,
  endTimeHour: 18,
  maxDailyHours: 9,
  lunchStartHour: 12,
  lunchDuration: 1,
  bufferMinutes: 15,
  morningEnergyHours: 3,
  afternoonEnergyHours: 3,
  eveningEnergyHours: 2,
  accommodationQuality: 'standard',
  includeMealBreaks: true,
  optimizeAccommodationLocation: true,
  allowLateArrival: false
}

/**
 * Enhanced day splitting with intelligent overflow handling
 */
export function splitIntoDaysEnhanced(
  itinerary: DetailedItinerary,
  config: Partial<EnhancedDailyConfig> = {}
): MultiDayItinerary {
  const finalConfig = { ...DEFAULT_ENHANCED_CONFIG, ...config }
  const dailySchedules: DaySchedule[] = []
  
  // Initialize tracking
  let currentDay: DaySchedule | null = null
  let dayNumber = 1
  let currentDate = new Date(itinerary.startDate)
  let dayStartTime = createDayStartTime(currentDate, finalConfig)
  let accumulatedHours = 0
  let lastLunchTime: Date | null = null
  
  // Group consecutive visits into potential days
  const visitGroups = intelligentGroupVisits(
    itinerary.destinationVisits,
    itinerary.transportSegments,
    finalConfig
  )
  
  // Process each visit group as a day
  for (const group of visitGroups) {
    currentDay = createNewDaySchedule(dayNumber, currentDate, finalConfig)
    accumulatedHours = 0
    
    // Add activities to the day
    for (const visit of group.visits) {
      const transport = findTransportBefore(visit, itinerary.transportSegments)
      
      // Add transport if exists
      if (transport && accumulatedHours > 0) {
        const transportActivity = createTransportActivity(
          transport,
          dayStartTime,
          accumulatedHours
        )
        currentDay.transportSegments.push(transportActivity)
        accumulatedHours += transport.estimatedTimeHours
      }
      
      // Check if lunch break needed
      if (finalConfig.includeMealBreaks && shouldInsertLunch(dayStartTime, accumulatedHours, lastLunchTime, finalConfig)) {
        const lunchActivity = createLunchActivity(dayStartTime, accumulatedHours, finalConfig)
        currentDay.meals.push(lunchActivity)
        accumulatedHours += finalConfig.lunchDuration
        lastLunchTime = lunchActivity.startTime
      }
      
      // Add destination
      const destinationActivity = createDestinationActivity(
        visit,
        dayStartTime,
        accumulatedHours
      )
      currentDay.activities.push(destinationActivity)
      accumulatedHours += visit.allocatedHours
      
      // Add buffer time
      accumulatedHours += finalConfig.bufferMinutes / 60
    }
    
    // Calculate actual end time
    currentDay.actualEndTime = new Date(
      dayStartTime.getTime() + accumulatedHours * 60 * 60 * 1000
    )
    
    // Add dinner if day extends late
    if (currentDay.actualEndTime.getHours() >= 18 && finalConfig.includeMealBreaks) {
      const dinnerActivity = createDinnerActivity(currentDay.actualEndTime)
      currentDay.activities.push(dinnerActivity)
    }
    
    // Finalize day
    currentDay = finalizeDaySchedule(currentDay, finalConfig)
    dailySchedules.push(currentDay)
    
    // Prepare for next day
    dayNumber++
    currentDate = new Date(currentDate)
    currentDate.setDate(currentDate.getDate() + 1)
    dayStartTime = createDayStartTime(currentDate, finalConfig)
  }
  
  // Generate accommodation suggestions
  const accommodationSuggestions = finalConfig.optimizeAccommodationLocation
    ? suggestAllAccommodations(dailySchedules, finalConfig.accommodationQuality)
    : []
  
  // Assign accommodations to days
  for (let i = 0; i < dailySchedules.length - 1; i++) {
    if (accommodationSuggestions[i]) {
      dailySchedules[i].accommodation = accommodationSuggestions[i]
    }
  }
  
  // Create multi-day summary
  const summary = createMultiDaySummary(dailySchedules, accommodationSuggestions)
  
  // Validate entire itinerary
  const validation = validateMultiDayItinerary(dailySchedules, itinerary)
  
  return {
    tripId: itinerary.tripId,
    startDate: itinerary.startDate,
    endDate: itinerary.endDate,
    dailySchedules,
    accommodationSuggestions,
    summary,
    validation
  }
}

/**
 * Intelligent grouping of visits into days
 */
function intelligentGroupVisits(
  visits: DestinationVisit[],
  transports: DetailedTransportSegment[],
  config: EnhancedDailyConfig
): { visits: DestinationVisit[], estimatedHours: number }[] {
  const groups: { visits: DestinationVisit[], estimatedHours: number }[] = []
  let currentGroup: DestinationVisit[] = []
  let currentHours = 0
  
  for (let i = 0; i < visits.length; i++) {
    const visit = visits[i]
    const transport = findTransportBefore(visit, transports)
    
    const transportTime = transport?.estimatedTimeHours || 0
    const visitTime = visit.allocatedHours
    const bufferTime = config.bufferMinutes / 60
    const totalTime = transportTime + visitTime + bufferTime
    
    // Check overflow conditions
    const wouldOverflow = currentHours + totalTime > config.maxDailyHours
    const isLongTransport = transportTime > 4
    const isLastVisit = i === visits.length - 1
    
    // Smart grouping: keep nearby destinations together
    const shouldSplit = wouldOverflow || isLongTransport || 
      (currentGroup.length > 0 && !areDestinationsNearby(currentGroup[currentGroup.length - 1], visit))
    
    if (shouldSplit && currentGroup.length > 0) {
      groups.push({ visits: currentGroup, estimatedHours: currentHours })
      currentGroup = []
      currentHours = 0
    }
    
    currentGroup.push(visit)
    currentHours += totalTime
    
    // Add lunch time if would cross noon
    if (config.includeMealBreaks && wouldCrossLunch(currentHours, config)) {
      currentHours += config.lunchDuration
    }
  }
  
  // Add final group
  if (currentGroup.length > 0) {
    groups.push({ visits: currentGroup, estimatedHours: currentHours })
  }
  
  // Optimize small consecutive days
  return optimizeDayGroups(groups, config)
}

/**
 * Check if destinations are nearby (same cluster or close distance)
 */
function areDestinationsNearby(dest1: DestinationVisit, dest2: DestinationVisit): boolean {
  // Same cluster
  if (dest1.clusterId === dest2.clusterId) return true
  
  // Calculate distance
  const distance = calculateDistance(dest1.location, dest2.location)
  return distance < 50 // Within 50km
}

/**
 * Calculate distance between locations
 */
function calculateDistance(loc1: any, loc2: any): number {
  const R = 6371
  const dLat = (loc2.latitude - loc1.latitude) * Math.PI / 180
  const dLon = (loc2.longitude - loc1.longitude) * Math.PI / 180
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(loc1.latitude * Math.PI / 180) * Math.cos(loc2.latitude * Math.PI / 180) *
    Math.sin(dLon/2) * Math.sin(dLon/2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
  return R * c
}

/**
 * Optimize day groups by merging under-utilized consecutive days
 */
function optimizeDayGroups(
  groups: { visits: DestinationVisit[], estimatedHours: number }[],
  config: EnhancedDailyConfig
): { visits: DestinationVisit[], estimatedHours: number }[] {
  if (groups.length <= 1) return groups
  
  const optimized: { visits: DestinationVisit[], estimatedHours: number }[] = []
  let i = 0
  
  while (i < groups.length) {
    const current = groups[i]
    const next = groups[i + 1]
    
    // Try to merge under-utilized consecutive days
    if (next && current.estimatedHours < 5 && next.estimatedHours < 5) {
      const combined = current.estimatedHours + next.estimatedHours + 0.5 // Travel between days
      
      if (combined <= config.maxDailyHours) {
        optimized.push({
          visits: [...current.visits, ...next.visits],
          estimatedHours: combined
        })
        i += 2 // Skip next group
        continue
      }
    }
    
    optimized.push(current)
    i++
  }
  
  return optimized
}

// Helper functions for activity creation

function createNewDaySchedule(
  dayNumber: number,
  date: Date,
  config: EnhancedDailyConfig
): DaySchedule {
  const startTime = new Date(date)
  startTime.setHours(config.startTimeHour, 0, 0, 0)
  
  const plannedEndTime = new Date(date)
  plannedEndTime.setHours(config.endTimeHour, 0, 0, 0)
  
  return {
    dayNumber,
    date: new Date(date),
    dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()],
    startTime,
    plannedEndTime,
    actualEndTime: plannedEndTime,
    activities: [],
    accommodation: null,
    summary: createEmptySummary(),
    validation: { isValid: true, warnings: [], errors: [] }
  }
}

function createTransportActivity(
  transport: DetailedTransportSegment,
  dayStart: Date,
  hoursIntoDay: number
): ScheduledActivity {
  const startTime = new Date(dayStart.getTime() + hoursIntoDay * 60 * 60 * 1000)
  const endTime = new Date(startTime.getTime() + transport.estimatedTimeHours * 60 * 60 * 1000)
  
  return {
    type: 'transport',
    name: `${transport.transportMode} to ${transport.toName}`,
    description: `${transport.distanceKm.toFixed(0)}km ${transport.transportMode}`,
    startTime,
    endTime,
    durationHours: transport.estimatedTimeHours,
    location: transport.toLocation,
    transportMode: transport.transportMode,
    transportIcon: transport.transportIcon
  }
}

function createDestinationActivity(
  visit: DestinationVisit,
  dayStart: Date,
  hoursIntoDay: number
): ScheduledActivity {
  const startTime = new Date(dayStart.getTime() + hoursIntoDay * 60 * 60 * 1000)
  const endTime = new Date(startTime.getTime() + visit.allocatedHours * 60 * 60 * 1000)
  
  return {
    type: 'destination',
    name: visit.destinationName,
    description: `Visit for ${visit.allocatedHours.toFixed(1)} hours`,
    startTime,
    endTime,
    durationHours: visit.allocatedHours,
    location: visit.location,
    wishlistCount: visit.wishfulUsers.length,
    visitDetails: visit
  }
}

function createLunchActivity(
  dayStart: Date,
  hoursIntoDay: number,
  config: EnhancedDailyConfig
): ScheduledActivity {
  // Schedule lunch at noon or current time, whichever is later
  const noonOffset = config.lunchStartHour - config.startTimeHour
  const lunchOffset = Math.max(noonOffset, hoursIntoDay)
  
  const startTime = new Date(dayStart.getTime() + lunchOffset * 60 * 60 * 1000)
  const endTime = new Date(startTime.getTime() + config.lunchDuration * 60 * 60 * 1000)
  
  return {
    type: 'meal',
    name: 'Lunch Break',
    description: 'Time for lunch and rest',
    startTime,
    endTime,
    durationHours: config.lunchDuration,
    location: { id: 'lunch', name: 'Lunch Location', latitude: 0, longitude: 0 },
    mealType: 'lunch'
  }
}

function createDinnerActivity(dayEndTime: Date): ScheduledActivity {
  const startTime = new Date(dayEndTime)
  const endTime = new Date(startTime.getTime() + 1.5 * 60 * 60 * 1000) // 1.5 hours for dinner
  
  return {
    type: 'meal',
    name: 'Dinner',
    description: 'Evening meal',
    startTime,
    endTime,
    durationHours: 1.5,
    location: { id: 'dinner', name: 'Dinner Location', latitude: 0, longitude: 0 },
    mealType: 'dinner'
  }
}

function shouldInsertLunch(
  dayStart: Date,
  hoursIntoDay: number,
  lastLunch: Date | null,
  config: EnhancedDailyConfig
): boolean {
  const currentTime = new Date(dayStart.getTime() + hoursIntoDay * 60 * 60 * 1000)
  const currentHour = currentTime.getHours()
  
  // Don't insert if just had lunch
  if (lastLunch && (currentTime.getTime() - lastLunch.getTime()) < 3 * 60 * 60 * 1000) {
    return false
  }
  
  // Insert if crossing lunch time
  return currentHour >= config.lunchStartHour && currentHour < config.lunchStartHour + 2
}

function wouldCrossLunch(hoursIntoDay: number, config: EnhancedDailyConfig): boolean {
  const startHour = config.startTimeHour
  const currentHour = startHour + hoursIntoDay
  const lunchHour = config.lunchStartHour
  
  return startHour + hoursIntoDay > lunchHour && startHour < lunchHour
}

// Day finalization and validation

function finalizeDaySchedule(
  day: DaySchedule,
  config: EnhancedDailyConfig
): DaySchedule {
  // Sort activities by start time
  day.activities.sort((a, b) => a.startTime.getTime() - b.startTime.getTime())
  
  // Calculate summary
  day.summary = calculateDaySummary(day)
  
  // Validate
  day.validation = validateDaySchedule(day, config)
  
  return day
}

function calculateDaySummary(day: DaySchedule): DaySummary {
  const destinations = day.activities.filter(a => a.type === 'destination')
  const transports = day.activities.filter(a => a.type === 'transport')
  const meals = day.activities.filter(a => a.type === 'meal')
  
  const totalActiveHours = destinations.reduce((sum, d) => sum + d.durationHours, 0)
  const totalTravelHours = transports.reduce((sum, t) => sum + t.durationHours, 0)
  const totalHours = totalActiveHours + totalTravelHours + meals.reduce((sum, m) => sum + m.durationHours, 0)
  
  // Calculate distances
  let walkingKm = 0, drivingKm = 0, flyingKm = 0
  for (const transport of transports) {
    if (transport.transportMode === 'walking') walkingKm += transport.transportDetails?.distanceKm || 0
    else if (transport.transportMode === 'driving') drivingKm += transport.transportDetails?.distanceKm || 0
    else if (transport.transportMode === 'flying') flyingKm += transport.transportDetails?.distanceKm || 0
  }
  
  // Determine pace
  let pace: 'relaxed' | 'moderate' | 'packed'
  if (totalHours < 6) pace = 'relaxed'
  else if (totalHours < 8) pace = 'moderate'
  else pace = 'packed'
  
  return {
    totalDestinations: destinations.length,
    totalActiveHours,
    totalTravelHours,
    totalDistanceKm: walkingKm + drivingKm + flyingKm,
    walkingDistanceKm: walkingKm,
    startTime: day.startTime,
    endTime: day.actualEndTime,
    pace,
    hasAccommodation: day.accommodation !== null,
    mealBreaks: meals.length
  }
}

function validateDaySchedule(
  day: DaySchedule,
  config: EnhancedDailyConfig
): DayValidation {
  const warnings: string[] = []
  const errors: string[] = []
  
  // Check total hours
  const totalHours = day.summary.totalActiveHours + day.summary.totalTravelHours
  if (totalHours > config.maxDailyHours) {
    warnings.push(`Day ${day.dayNumber} exceeds recommended ${config.maxDailyHours} hours (${totalHours.toFixed(1)}h)`)
  }
  
  // Check end time
  if (!config.allowLateArrival && day.actualEndTime.getHours() > config.endTimeHour) {
    warnings.push(`Day ${day.dayNumber} ends after ${config.endTimeHour}:00 (${day.actualEndTime.toLocaleTimeString()})`)
  }
  
  // Check walking distance
  if (day.summary.walkingDistanceKm > 10) {
    warnings.push(`Day ${day.dayNumber} has extensive walking (${day.summary.walkingDistanceKm.toFixed(1)}km)`)
  }
  
  // Check pace
  if (day.summary.pace === 'packed' && day.dayNumber > 1) {
    warnings.push(`Day ${day.dayNumber} has a packed schedule after previous days`)
  }
  
  return {
    isValid: errors.length === 0,
    warnings: warnings.map(msg => ({ 
      code: 'DAY_SCHEDULE_WARNING',
      message: msg,
      severity: 'warning' as const
    })),
    errors: errors.map(msg => ({
      code: 'DAY_SCHEDULE_ERROR',
      message: msg,
      severity: 'error' as const
    }))
  }
}

// Multi-day summary and validation

function createMultiDaySummary(
  days: DaySchedule[],
  accommodations: AccommodationSuggestion[]
): any {
  const totalDays = days.length
  const totalDestinations = days.reduce((sum, d) => sum + d.summary.totalDestinations, 0)
  const totalDistanceKm = days.reduce((sum, d) => sum + d.summary.totalDistanceKm, 0)
  const totalActiveHours = days.reduce((sum, d) => sum + d.summary.totalActiveHours, 0)
  const totalTravelHours = days.reduce((sum, d) => sum + d.summary.totalTravelHours, 0)
  
  // Calculate accommodation costs
  const accommodationCosts = accommodations.map(a => a.estimatedCostUSD)
  const totalAccommodationCost = accommodationCosts.reduce((sum, cost) => sum + cost, 0)
  
  // Daily statistics
  const avgDestinationsPerDay = totalDestinations / totalDays
  const avgDistancePerDay = totalDistanceKm / totalDays
  const avgActiveHoursPerDay = totalActiveHours / totalDays
  
  // Pace distribution
  const paceDistribution = {
    relaxed: days.filter(d => d.summary.pace === 'relaxed').length,
    moderate: days.filter(d => d.summary.pace === 'moderate').length,
    packed: days.filter(d => d.summary.pace === 'packed').length
  }
  
  return {
    totalDays,
    totalDestinations,
    totalDistanceKm,
    totalActiveHours,
    totalTravelHours,
    totalAccommodationCost,
    averageAccommodationCost: totalDays > 1 ? totalAccommodationCost / (totalDays - 1) : 0,
    dailyAverages: {
      destinationsPerDay: avgDestinationsPerDay,
      distancePerDay: avgDistancePerDay,
      activeHoursPerDay: avgActiveHoursPerDay
    },
    paceDistribution,
    transportBreakdown: calculateTransportBreakdown(days),
    restDayRecommendation: shouldRecommendRestDay(days)
  }
}

function calculateTransportBreakdown(days: DaySchedule[]): any {
  let walking = 0, driving = 0, flying = 0
  
  for (const day of days) {
    walking += day.summary.walkingDistanceKm
    // Add driving and flying from transport details if available
  }
  
  return { walkingKm: walking, drivingKm: driving, flyingKm: flying }
}

function shouldRecommendRestDay(days: DaySchedule[]): string | null {
  const consecutivePackedDays = findConsecutivePackedDays(days)
  
  if (consecutivePackedDays >= 3) {
    return `Consider adding a rest day after ${consecutivePackedDays} packed days`
  }
  
  if (days.length >= 7 && !hasRelaxedDay(days)) {
    return 'Consider including at least one relaxed day in your week-long trip'
  }
  
  return null
}

function findConsecutivePackedDays(days: DaySchedule[]): number {
  let maxConsecutive = 0
  let current = 0
  
  for (const day of days) {
    if (day.summary.pace === 'packed') {
      current++
      maxConsecutive = Math.max(maxConsecutive, current)
    } else {
      current = 0
    }
  }
  
  return maxConsecutive
}

function hasRelaxedDay(days: DaySchedule[]): boolean {
  return days.some(d => d.summary.pace === 'relaxed')
}

function validateMultiDayItinerary(
  days: DaySchedule[],
  originalItinerary: DetailedItinerary
): any {
  const errors: string[] = []
  const warnings: string[] = []
  
  // Check all destinations included
  const scheduledDestIds = new Set<string>()
  for (const day of days) {
    for (const activity of day.activities) {
      if (activity.type === 'destination' && activity.visitDetails) {
        scheduledDestIds.add(activity.visitDetails.destinationId)
      }
    }
  }
  
  const originalDestIds = new Set(originalItinerary.destinationVisits.map(v => v.destinationId))
  if (scheduledDestIds.size !== originalDestIds.size) {
    errors.push('Not all destinations were scheduled in daily plans')
  }
  
  // Check date consistency
  if (days.length > 0) {
    const firstDay = days[0].date
    const lastDay = days[days.length - 1].date
    
    if (firstDay.toDateString() !== originalItinerary.startDate.toDateString()) {
      errors.push('Start date mismatch between itinerary and daily schedule')
    }
  }
  
  // Warnings for optimization opportunities
  const avgDestPerDay = days.reduce((sum, d) => sum + d.summary.totalDestinations, 0) / days.length
  if (avgDestPerDay < 1.5 && days.length > 3) {
    warnings.push('Low destination density - consider combining some days')
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    scheduledDestinationCount: scheduledDestIds.size,
    originalDestinationCount: originalDestIds.size
  }
}

function createEmptySummary(): DaySummary {
  return {
    totalDestinations: 0,
    totalActiveHours: 0,
    totalTravelHours: 0,
    totalDistanceKm: 0,
    walkingDistanceKm: 0,
    startTime: new Date(),
    endTime: new Date(),
    pace: 'relaxed',
    hasAccommodation: false,
    mealBreaks: 0
  }
}

// Export helpers
export function findTransportBefore(
  visit: DestinationVisit,
  segments: DetailedTransportSegment[]
): DetailedTransportSegment | null {
  return segments.find(s => 
    s.toLocation.latitude === visit.location.latitude &&
    s.toLocation.longitude === visit.location.longitude &&
    Math.abs(s.arrivalTime.getTime() - visit.arrivalTime.getTime()) < 60000 // Within 1 minute
  ) || null
}

export { createDayStartTime } from './day-splitter'